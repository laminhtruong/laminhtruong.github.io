[1,["1a7468552@6c48a","e2uRISfu5MxLMoT+f2TEdu@f9941","51V+p7Zt1NDbMzgUVpCq0x","20g1ukYUVPvKWKBRznAKo+@f9941","88A6d07iNLSaRkaORvPaEN","69THl8CTRHe42k/C5WgHvu@f9941","7fFz8RNk5CgYDm7hmnra4/","15DyFwMQ1BgKNwJkeUufkb@f9941","836yr8qLBBH6v4l45wp2l2@6c48a","7ewTkjDxlIYYeENMA3mC8w@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","199dbc35f@6c48a","c3qMYD/7FOR4tU/q0feraG@f9941","969WVMeoRIt7JvKrq5OMI+","8ahMOAAftDboobZSHonVAy","e00c0trElNk4ufxzKBASLR","22TbdrVWhCQr9E4IR1zjWB@f9941","3d53wxdQlLsoC/5P0yZ4EO@f9941","4bEmi6rDpGOotcKEFgTgh6@f9941","d7iAycONZLjbS7fvx8FdiV@f9941","3e+vAy1ttBIb5aOViD2mQQ@f9941","03qLmiB2FKNIQ/Oai3ne0+@f9941","78q26pg5hG85/QLom1Nrjp","43cxfhTEpDJJR4Qnka9AXX@f9941","fdSEV6iLpN8YQP4pqqdYeH@f9941","20g1ukYUVPvKWKBRznAKo+@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","f56i//Q3NBSKDKqlZvaT6X@f9941","f9d/1Y9BRMZpOmhT8k47aI@f9941","95EkngnxZFbYuFpsqVTaFr@6c48a","d1NGQ2rJZCcbhjH0/erZWw","a6RC7arGZOL4FuNB81yd04@f9941","cfoh2gEnZLyIQZSFfj0hy7@f9941","e8h+9K415L95FgUaVj8zBo@f9941","ffjs38++1DB5YMsnayAY1/@f9941","dcZUS9UklAh7kyBcFVt4EF@f9941","7bezKBZrJIHKAUgWC8Tw71@f9941","f2dna4OWpB0IMyk21r1ZDW@f9941","f1lA2++0VG1Zbb4N7b15sN@f9941","94PiB+3HZGyZxCnSimlYbV@f9941","d0jUsIZcVG3aQg58p2Im4i@f9941","bd2Azsv11Bx7cg+3Xqj0yM@f9941","a4vzUWXWhHMpeh9To8BQo2@f9941","b4TqwhPJpOv5osY+eFmNjc","c4WU7Oc5ZE37KJhjLUU5Ik","85DE6oKK1IG791cMZWQO5D@f9941","cbfYen60hGtLGwV4CgKzDB@f9941","6bZ2RlGdtCUbO0qSzblPgm@f9941"],["node","_spriteFrame","_textureSource","_font","root","asset","_normalSprite","_target","targetInfo","_parent","_hoverSprite","_pressedSprite","_disabledSprite","data","_particleSystem","_mainTexture","icon","bg","light","mainTexture","_effectAsset","_cameraComponent","scrollingText","audioTap","popupHistory","popupExchangeTurn","popupGift","popupWarning","popupError","loading","main","curve","scene","buttonBack","buttonHistory","buttonSpin","turns","overlay","spinner","_scrollView","_defaultClip","_clip","prefabItem","_userDefinedFont","spirteSpinNormal","spirteSpinDisable","time","description","information"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_id","_active","_components","_parent","_children","_lpos","_prefab","_lscale","_lrot","_euler"],-1,9,1,2,5,4,5,5,5],["cc.Sprite",["_sizeMode","_type","_fillType","_fillStart","_fillRange","node","__prefab","_spriteFrame","_color","_fillCenter"],-2,1,4,6,5,5],["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_top","_left","_right","_bottom","_alignMode","node","__prefab"],-5,1,4],["cc.Node",["_name","_layer","_active","_components","_parent","_lpos","_children","_prefab","_lscale","_lrot","_euler"],0,12,1,5,2,4,5,5,5],["cc.Label",["_actualFontSize","_string","_overflow","_isSystemFontUsed","_fontSize","_isBold","_horizontalAlign","_lineHeight","_enableWrapText","_isItalic","node","__prefab","_color","_font"],-7,1,4,5,6],"cc.ImageAsset","cc.Texture2D",["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.CurveRange",["mode","constantMax","constant","constantMin","curve"],-1,1],["cc.Button",["_transition","_zoomScale","node","__prefab","clickEvents","_normalColor","_target","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],1,1,4,9,5,1,6,6,6,6],["cc.Keyframe",["value","time"],1],["cc.Node",["_name","_components","_parent","_lpos"],2,2,1,5],["cc.PrefabInfo",["fileId","targetOverrides","root","asset"],1,1,1],["cc.Layout",["_layoutType","_spacingX","_resizeMode","node"],0,1],["cc.Mask",["node","__prefab"],3,1,4],["cc.AudioSource",["_loop","_playOnAwake","node"],1,1],["cc.ParticleSystem",["loop","playOnAwake","_capacity","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","bursts"],0,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9],["cc.ShapeModule",["_enable","radius","_angle","emitFrom","_shapeType","arcSpeed","_rotation","_scale"],-2,4,5,5],["cc.ForceOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.LimitVelocityOvertimeModule",["dampen","_enable","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents"],1,9,9],["cc.Camera",["_visibility","_projection","_priority","_orthoHeight","_far","_clearFlags","node","_color"],-3,1,5],["cc.RichText",["_fontSize","_isSystemFontUsed","_string","_horizontalAlign","_lineHeight","_maxWidth","node","__prefab"],-3,1,4],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],["cc.TTFFont",["_name","_native"],1],["cc.AnimationClip",["_name","speed","wrapMode","_duration","_hash","_curves","_keys","_commonTargets"],-4,12],["cc.animation.HierarchyPath",["path"],2],["cc.Prefab",["_name"],2],["cc.CompPrefabInfo",["fileId"],2],["80778T/Aw5KTqtRMvdABmlf",["node","__prefab","bg","icon","light"],3,1,4,1,1,1],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.Material",["_techIdx","_states","_defines","_props"],0,12],["cc.SceneAsset",["_name"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.BlockInputEvents",["node"],3,1],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["180c9lqTTZHVpxGKnnQEokO",["node","lights"],3,1,2],["cc.ClickEvent",["_componentId","handler","target"],1,1],["59a412K1NxEW77Yknuvdy8e",["node","items"],3,1,2],["e6329fh7QdHiYn7arpg1TCs",["node","Notifications","scrollingText"],3,1,2,1],["cc.LabelOutline",["node","_color"],3,1,5],["cc.LabelShadow",["node","_color","_offset"],3,1,5,5],["cc.TargetInfo",["localID"],2],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",[],3],["2df67cPW6dPX48dJVTWAnOy",["node","main","loading","popupError","popupWarning","popupGift","popupExchangeTurn","popupHistory","audioTap"],3,1,1,1,1,1,1,1,1,1],["cc.GradientRange",[],3],["cc.CurveRange",["mode","curve"],2,4],["cc.Burst",["repeatInterval","count"],2,4],["cc.ColorOvertimeModule",["color"],3,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","cycleCount","randomRow","rowIndex","frameOverTime","startFrame"],-3,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.AnimationCurve",["preWrapMode","postWrapMode","keyFrames"],1,9],["cc.MountedComponentsInfo",["components","targetInfo"],2,4],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["418ddTz9+lC7bF5livsSJvo",["node","turnLogin","turnWithoutLogin","confettiDrop"],3,1,1,1,1],["9c69ay9pCVG/5YDrJ1oySld",["node","container"],3,1,1],["ae5e6oHii1DAp8iAq9daOTv",["node","container","gift","particleWin"],3,1,1,1,2],["b495dvYo/BJlKfocklL9tQG",["node","container","buttonMinus","buttonAdd","buttonExchange","labelTurn","labelCoin","labelRate"],3,1,1,1,1,1,1,1,1],["cd786OL4KtC4rtPw+E8R6+f",["node","container","message"],3,1,1,1],["cc.ScrollBar",["_direction","node","__prefab","_handle"],2,1,4,1],["cc.ScrollView",["bounceDuration","brake","horizontal","node","__prefab","_content","_verticalScrollBar"],0,1,4,1,1],["bdf99lAQSJLuJR79SBJsE50",["node","container","content"],3,1,1,1],["f2b2fXBSjhBZ4KwKnXZ/HX5",["node","overlay"],3,1,1],["bf50fwUJItJvYyJzbCOdU+b",["node","background","text"],3,1,1,1],["729d4KJjzhGfL0qDutk2ZsF",["node","light"],3,1,1],["c86cddfDZxLm7NGiOKG8yCW",["node","light","items"],3,1,1,2],["cc.AudioClip",["_name","_native","_duration"],0],["2ae10c7koBII5m9zSeuZOfS",["node","__prefab","bg","icon","description","time"],3,1,4,1,1,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["45db9SjQ7xMLrjPwl8puXSz",["node","__prefab","information"],3,1,4,1],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[29,0,2],[9,1],[8,0,2,1,1],[67,0,1,2,2],[1,0,1,5,4,7,3],[9,0,3,1,4],[8,0,1,1],[43,0,2],[38,0,1,2,3],[9,2,2],[3,0,1,2,8,4],[66,0,1,2,3],[1,5,8,1],[31,0,1,2,3,2],[52,1],[1,0,1,5,4,3],[8,0,2,1,3,1],[21,0,2,2],[13,0,2,3,2],[65,0,1,2,2],[1,0,1,5,6,4,3],[2,5,7,1],[1,0,1,5,6,4,7,3],[2,0,5,6,7,2],[2,1,0,5,7,3],[4,0,1,4,6,3,5,3],[2,0,5,6,8,7,2],[41,0,1,1],[42,0,1,2,1],[4,0,1,4,3,5,3],[35,0,1],[2,1,0,5,6,7,3],[3,0,4,5,3,6,1,2,8,8],[10,0,1,2,3,4,5,6,3],[5,1,0,4,2,3,5,10,11,13,7],[4,0,2,4,6,3,3],[2,5,6,7,1],[10,0,1,2,3,4,5,6,7,8,9,10,3],[28,0,2],[4,0,1,4,3,3],[2,0,5,6,2],[2,5,6,8,7,1],[3,0,6,1,2,8,5],[10,0,1,2,3,4,5,6,7,3],[44,0,1,1],[9,0,1,3],[55,0,1],[56,0,1,2,3,4,2],[57,0,1,2,3,1],[58,0,1,2,3,2],[59,0,1,2,3,4,5,6,7,7],[60,0,1,2,3,4,1],[61,0,1],[4,0,2,1,4,3,5,8,4],[4,0,1,4,3,7,5,3],[8,0,1],[3,0,1,8,3],[17,0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,29,19,20,21,22,23,24,25,26,27,28,3],[9,0,4,2],[54,0,1,2],[18,0,3,1,2,5,6,5],[19,0,1,2,3,2],[20,1,0,2,3,4,5,3],[11,1,0,3],[25,0,1,3],[1,0,1,6,4,8,7,3],[1,0,1,6,4,3],[1,0,1,5,4,9,3],[1,0,1,5,4,7,10,9,11,3],[4,0,1,4,3,7,3],[8,0,1,3,1],[3,0,3,8,3],[3,0,5,8,3],[3,0,3,6,1,2,8,6],[5,1,6,0,4,2,3,5,10,11,13,8],[5,1,0,4,2,8,3,5,10,11,13,8],[5,1,0,4,2,3,10,11,6],[62,0,1,2,3],[11,0,2],[26,0,1,2,3,4,5,6,7,8],[27,0,2],[1,0,1,5,4,8,3],[1,0,1,5,4,8,7,3],[1,0,1,4,8,3],[1,0,1,2,6,4,7,4],[1,0,6,4,2],[1,0,1,6,4,7,3],[1,0,3,1,6,4,4],[1,0,5,6,4,7,2],[1,0,1,4,7,3],[1,0,3,1,5,4,4],[1,0,1,5,4,7,9,3],[1,0,2,5,6,4,3],[1,0,5,6,4,2],[1,0,2,5,4,7,10,11,3],[1,0,1,5,6,4,8,3],[1,0,1,6,4,8,3],[4,0,1,4,3,7,5,9,10,3],[4,0,6,3,2],[4,0,2,1,4,6,3,4],[4,0,1,4,6,3,3],[4,0,2,1,4,3,4],[4,0,1,4,3,5,8,3],[12,0,1,2],[12,0,2,1,3,2],[30,0,1,2,3,4,1],[13,1,2],[2,1,2,0,3,4,5,6,8,9,7,6],[2,2,0,5,6,9,7,3],[2,1,0,5,6,8,7,3],[2,1,0,5,6,8,3],[2,0,5,6,8,2],[2,1,2,5,9,3],[32,0,1,2,3,4],[33,0,2],[3,0,8,9,2],[3,0,2,7,8,9,4],[3,0,4,5,3,1,8,6],[3,0,4,8,3],[3,0,4,5,1,2,7,8,7],[3,0,4,5,3,6,1,2,7,8,9],[3,0,1,2,7,8,9,5],[34,0,1,2,1],[14,0,1,3,3],[14,2,0,3,3],[36,0,1,2,3,2],[15,0,1],[15,0,1,1],[37,0,1,1],[39,0,1,1],[40,0,1,2,1],[5,1,0,2,3,5,10,11,13,6],[5,1,0,4,2,3,5,10,11,12,13,7],[5,1,6,0,4,7,2,8,3,5,10,11,12,13,10],[5,1,6,0,4,7,2,3,5,10,11,12,13,9],[5,1,6,0,4,7,2,9,10,11,12,8],[5,1,0,4,2,3,10,11,12,6],[5,1,6,0,4,3,5,10,11,12,7],[5,1,6,0,4,7,2,3,10,11,12,8],[5,0,4,2,8,3,10,11,12,6],[45,0,1,2,3,2],[46,0,1,2,3,1],[47,1],[48,0,1],[49,1],[50,1],[51,0,1,2,3,4,5,6,7,8,1],[16,0,2,2],[16,1,2,2],[17,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2],[53,0,1,2],[18,0,4,1,2,5,7,5],[19,1,2,3,1],[20,0,2,3,4,5,2],[11,1,2],[21,0,1,3,2,3],[63,0,1,2],[64,0,1,2,3],[22,0,6,7,2],[22,1,2,3,4,5,0,6,7,7],[68,0,1,2,3,1],[69,0,1,1],[70,0,1,2,3,1],[71,0,1,2,3,4,5,6,7,1],[72,0,1,2,1],[73,0,1,2,3,2],[74,0,1,2,3,4,5,6,4],[75,0,1,2,1],[76,0,1,1],[77,0,1,2,1],[78,0,1,1],[79,0,1,2,1],[23,2,3,0,1,6,7,5],[23,4,0,5,1,6,7,5],[80,0,1,2,4],[81,0,1,2,3,4,5,1],[82,0,1,2,4],[83,0,1,2,1],[84,0,1],[85,0,1,2],[86,0,2],[87,0,1,2,3],[88,0,1,2],[24,0,2],[24,1,2,0,4]],[[[{"name":"popup_textbox","rect":{"x":1334,"y":1968,"width":60,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":60,"height":66},"rotated":true,"capInsets":[20,20,20,20],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"button_pink_glow","rect":{"x":1836,"y":3,"width":328,"height":109},"offset":{"x":0,"y":0},"originalSize":{"width":328,"height":109},"rotated":true,"capInsets":[50,45,50,45],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"fmt":"0","w":676,"h":1639}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["199dbc35f"]}],[7],0,[],[],[]],[[{"fmt":"0","w":2045,"h":2042}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["1a7468552"]}],[7],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["20g1ukYUVPvKWKBRznAKo+"]}],[7],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"20835ba4-6145-4fbc-a58a-051ce700aa3e@6c48a","packable":true}],[0],0,[0],[2],[26]],[[{"name":"btt_spin_a","rect":{"x":1492,"y":1765,"width":359,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":359,"height":182},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_download_apple","rect":{"x":1492,"y":1953,"width":258,"height":86},"offset":{"x":0,"y":0},"originalSize":{"width":258,"height":86},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_add","rect":{"x":1924,"y":1865,"width":54,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":58},"rotated":true,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"deco_voucher_1","rect":{"x":1836,"y":337,"width":178,"height":139},"offset":{"x":0,"y":0},"originalSize":{"width":178,"height":139},"rotated":true,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_download_google","rect":{"x":1756,"y":1953,"width":258,"height":77},"offset":{"x":0,"y":0},"originalSize":{"width":258,"height":77},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[64,"utm-avo","utm-avo.ttf"]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["54TknWPwVPqJqeCR+Y/Czo"]}],[7],0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@6c48a","packable":true}],[0],0,[0],[2],[27]],[[{"name":"icon_loading_dota","rect":{"x":1149,"y":2010,"width":13,"height":17},"offset":{"x":0,"y":0},"originalSize":{"width":17,"height":21},"rotated":true,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"notification_bg","rect":{"x":1149,"y":1968,"width":100,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":100,"height":36},"rotated":false,"capInsets":[30,0,30,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[79,"loading",2,22,1.3333333333333333,213801,[{"commonTarget":0,"modifiers":["x"],"data":{"keys":0,"values":[-63.5,-45.5,-27.5,-9.5,8.5,26.5,44.5,62.5,-63.5],"easingMethods":{"0":"constant","1":"constant","2":"constant","3":"constant","4":"constant","5":"constant","6":"constant","7":"constant","8":"constant"}}},{"commonTarget":0,"modifiers":["y"],"data":{"keys":1,"values":[],"easingMethods":{}}},{"commonTarget":0,"modifiers":["z"],"data":{"keys":2,"values":[],"easingMethods":{}}}],[[0,0.16666666666666666,0.3333333333333333,0.5,0.6666666666666666,0.8333333333333334,1,1.1666666666666667,1.3333333333333333],[],[]],[[[{},"modifiers",12,[[[80,"DogBig"],"position"],4,0]]],11]]],0,0,[],[],[]],[[{"name":"bg","rect":{"x":3,"y":3,"width":1128,"height":1500},"offset":{"x":0,"y":0},"originalSize":{"width":1128,"height":1500},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"popup_close","rect":{"x":1857,"y":1865,"width":61,"height":61},"offset":{"x":0,"y":0},"originalSize":{"width":61,"height":61},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[38,"ItemSpin"],[65,"ItemSpin",33554432,[-7,-8,-9],[[16,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,269,309],[0,0.089,0.08]],[105,-6,[0,"270UhrKwJN4Yj+pLBLmdV7"],-5,-4,-3]],[18,"3empOM9gJKLaiwBBtK/4Le",-1,0],[1,-0.3140000000000214,48.29399999999998,0]],[81,"Bg",33554432,1,[[16,-10,[0,"f7NISe7HdAD68SLfhnddy8"],[5,269,309],[0,0.089,0.08]],[36,-11,[0,"e71ctEmpxFC4KlSYRZNz/a"],0]],[18,"d5xvKmkx5H6ZYUU2PHgO4p",1,0]],[82,"Light",33554432,1,[[2,-12,[0,"f7NISe7HdAD68SLfhnddy8"],[5,311,356]],[36,-13,[0,"e71ctEmpxFC4KlSYRZNz/a"],1]],[18,"c31js76TJAZbcrJTiPU30m",1,0],[1,90.5,136.962,0]],[97,"Icon",33554432,1,[[[2,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,200,200]],-15],4,1],[18,"4e8fX8HyVOrpgIKHxs5Kac",1,0],[1,75,184,0],[3,0,0,-0.19509032201612825,0.9807852804032304],[1,0,0,-22.5]],[40,2,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]]],0,[0,4,1,0,0,1,0,18,3,0,16,5,0,17,2,0,0,1,0,-1,2,0,-2,4,0,-3,3,0,0,2,0,0,2,0,0,3,0,0,3,0,0,4,0,-2,5,0,13,1,15],[0,0],[1,1],[28,29]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["836yr8qLBBH6v4l45wp2l2"]}],[7],0,[],[],[]],[[{"name":"luckywheel_lighton","rect":{"x":1137,"y":737,"width":710,"height":710},"offset":{"x":0,"y":0},"originalSize":{"width":710,"height":710},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[64,"iCielPanton-Black","iCielPanton-Black.ttf"]],0,0,[],[],[]],[[[38,"Light"],[83,"Light",33554432,[[16,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,150,2000],[0,0.5,0]],[107,3,2,0,0.244,0.015,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4293983231],[0,0.5,0],0]],[18,"b2fdGMTRlIcIXQiFGMJj1n",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,13,1,3],[0],[1],[1]],[[{"name":"luckywheel_base","rect":{"x":3,"y":679,"width":640,"height":640},"offset":{"x":0,"y":0},"originalSize":{"width":640,"height":640},"rotated":false,"capInsets":[0,0,0,0],"texture":"199dbc35f@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["95EkngnxZFbYuFpsqVTaFr"]}],[7],0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"951249e0-9f16-456d-8b85-a6ca954da16b@6c48a","packable":true}],[0],0,[0],[2],[30]],[[[113,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[19,20],[8,31]],[[[114,"main"],[98,"Main",[-4,-5,-6,-7,-8,-9,-10,-11],[[[6,-1,[5,750,1500]],-2,[10,45,100,100,-3]],4,1,4]],[103,"Tap",[-12]],[84,"Canvas",33554432,"0dDmbhkC9Ftb0hdJwrl+Yu",[-17,1,-18,-19,-20,-21,-22,-23,-24],[[2,-13,[0,"0dngp/9gNO34wUQjZfN/CX"],[5,750,1500]],[122,-15,[0,"3f2oTdCepERZdpmIfLsrhd"],-14],[115,45,-16,[0,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,375,750,0]],[66,"Container",33554432,[-27,-28,-29,-30,-31,-32,-33,-34],[[6,-25,[5,750,1500]],[10,45,100,100,-26]]],[35,"PopupGift",false,3,[-38,-39,-40,-41,-42],[[[6,-35,[5,750,1500]],[10,45,100,100,-36],-37],4,4,1]],[35,"PopupExchangeTurn",false,3,[-46,4],[[[6,-43,[5,750,1500]],-44,[10,45,100,100,-45]],4,1,4]],[66,"Dots",33554432,[-49,-50,-51,-52,-53,-54,-55,-56],[[6,-47,[5,140,50]],[123,1,5,-48]]],[85,"Items",[-58,-59,-60,-61,-62,-63,-64,-65],[[55,-57]]],[35,"PopupWarning",false,3,[-69,-70],[[[6,-66,[5,750,1500]],[10,45,100,100,-67],-68],4,4,1]],[20,"Container",33554432,5,[-73,-74,-75,-76,-77],[[6,-71,[5,750,1500]],[10,45,100,100,-72]]],[99,"Loading",false,33554432,3,[-82,-83,7,-84],[[[6,-78,[5,750,1500]],[30,-79],[125,true,-80,[80],81],-81],4,4,4,1]],[86,"Light",33554432,[-93,-94,-95,-96],[[70,-85,[5,1128,880],[0,0.5,1]],[126,-86],[56,41,100,-87],[128,-92,[-88,-89,-90,-91]]],[1,0,750,0]],[100,"Spinner",33554432,1,[-99,-100,-101,-102,-103,8],[[[55,-97],-98],4,1]],[20,"Container",33554432,9,[-106,-107,-108,-109],[[6,-104,[5,750,1500]],[10,45,100,100,-105]]],[25,"ButtonSpin",33554432,1,[-114,-115],[[[2,-110,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,359,182]],[108,2,0,-111,[0,"77BcV1zfNHo4LI4KRqZupe"],[0,0.5,0.5],112],-112,[71,1,1084,-113]],4,4,1,4],[1,0,-425,0]],[22,"Turns",33554432,4,[-118,-119,-120,-121],[[6,-116,[5,320,66]],[24,1,0,-117,34]],[1,100,100,0]],[22,"ButtonShare",33554432,4,[-126,-127],[[2,-122,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[24,1,0,-123,42],[43,3,0.9,-125,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Share",6],[8,"cc.AudioSource","play",2]],[4,4292269782],-124,43]],[1,0,-190,0]],[35,"PopupError",false,3,[-131,-132],[[[6,-128,[5,750,1500]],[10,45,100,100,-129],-130],4,4,1]],[20,"Container",33554432,18,[-135,-136,-137],[[6,-133,[5,750,1500]],[10,45,100,100,-134]]],[35,"PopupHistory",false,3,[-141,-142],[[[6,-138,[5,750,1500]],[10,45,100,100,-139],-140],4,4,1]],[20,"Container",33554432,20,[-145,-146,-147],[[6,-143,[5,750,1500]],[10,45,100,100,-144]]],[87,"Floating",false,33554432,[-154,-155,-156,-157],[[55,-148],[129,-153,[-149,-150,-151,-152]]]],[88,"Notification",1,[-165,-166,-167,-168],[[70,-158,[5,650,135],[0,0.5,0]],[130,-164,[-160,-161,-162,-163],-159]],[1,0,-750,0]],[22,"ButtonShare",33554432,10,[-173],[[2,-169,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[24,1,0,-170,20],[43,3,0.9,-172,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"ae5e6oHii1DAp8iAq9daOTv","Share",5],[8,"cc.AudioSource","play",2]],[4,4292269782],-171,21]],[1,0,-210,0]],[39,"Value",33554432,16,[[[2,-174,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,66]],-175,[10,45,42.26,50.4,-176],[27,-177,[4,4289425681]],[28,-178,[4,4283776010],[0,0,-2]]],4,1,4,4,4]],[22,"Rate",33554432,4,[-181,-182,-183],[[6,-179,[5,320,66]],[24,1,0,-180,37]],[1,100,0,0]],[39,"Value",33554432,26,[[[2,-184,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,66]],-185,[10,45,42.26,50.4,-186],[27,-187,[4,4289425681]],[28,-188,[4,4283776010],[0,0,-2]]],4,1,4,4,4]],[25,"ButtonExchange",33554432,4,[-192],[[[2,-189,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[24,1,0,-190,39],-191],4,4,1],[1,0,-100,0]],[20,"Border",33554432,21,[-196,-197],[[2,-193,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,740]],[31,1,0,-194,[0,"e71ctEmpxFC4KlSYRZNz/a"],62],[32,18,63,63,370,370,624,760,-195]]],[25,"ScrollView",33554432,29,[-201,-202],[[[16,-198,[0,"71kmounFRG/K27WWBbH2RB"],[5,616,500],[0,0.5,1]],-199,[32,45,4,4,190,50,240,250,-200]],4,1,4],[1,0,180,0]],[25,"scrollBar",33554432,30,[-207],[[[16,-203,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,5,500],[0,1,0.5]],[109,1,0,-204,[0,"9dLJe/n0BKVoGauB1wT/Tc"],[4,4292861919],61],[116,37,250,1,-205,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-206],4,4,4,1],[1,308,-250,0]],[25,"ButtonBack",33554432,3,[-211],[[[2,-208,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],-209,[117,9,-35,25,50,100,-210]],4,1,4],[1,-335,625,0]],[25,"ButtonHistory",33554432,1,[-215],[[[2,-212,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,122,141]],-213,[72,32,10,-214]],4,1,4],[1,304,375,0]],[25,"NotificationWinner",33554432,1,[-219,-220],[[[2,-216,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,50]],-217,[56,40,64,-218]],4,1,4],[1,0,625,0]],[7,["7aFiDHn+NClKHPLQ2dj3zj"]],[20,"TurnLogin",33554432,15,[-223,-224],[[6,-221,[5,359,182]],[10,45,100,100,-222]]],[15,"Overlay",33554432,9,[[2,-225,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-226,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],0],[30,-227],[10,45,20,20,-228]]],[4,"ButtonDownloadApple",33554432,14,[[2,-229,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,258,86]],[24,1,0,-230,2],[43,3,0.9,-232,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","DownloadApple",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-231,3]],[1,0,-180,0]],[4,"ButtonDownloadGoogle",33554432,14,[[2,-233,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,258,86]],[24,1,0,-234,4],[43,3,0.9,-236,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","DownloadGoogle",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-235,5]],[1,0,-280,0]],[22,"ButtonClose",33554432,14,[-240],[[2,-237,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-239,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","Close",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-238,7,8,9,10]],[1,0,-460,0]],[15,"Overlay",33554432,5,[[2,-241,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-242,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],11],[30,-243],[10,45,20,20,-244]]],[4,"Title",33554432,10,[[2,-245,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,90]],[131,"KẾT QUẢ VÒNG QUAY",40,1,false,true,-246,[0,"2frm37uaJHQr0AEEaYyM82"],13],[27,-247,[4,4289425681]],[28,-248,[4,4283776010],[0,0,-2]]],[1,0,245,0]],[22,"ButtonClose",33554432,10,[-252],[[2,-249,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-251,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"ae5e6oHii1DAp8iAq9daOTv","Close",5],[8,"cc.AudioSource","play",2]],[4,4292269782],-250,15,16,17,18]],[1,0,-360,0]],[53,"ParticleLeft",false,33554432,5,[[-253,[2,-254,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-255,[0,"50bRhRSqFKc4o+eXu3VyY/"]],[118,8,-20,-256]],1,4,4,4],[1,-370,-780,0],[1,50,50,50]],[53,"ParticleRight",false,33554432,5,[[-257,[2,-258,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-259,[0,"50bRhRSqFKc4o+eXu3VyY/"]],[72,32,-20,-260]],1,4,4,4],[1,370,-780,0],[1,50,50,50]],[15,"Overlay",33554432,6,[[2,-261,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-262,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],28],[30,-263],[10,45,20,20,-264]]],[4,"Title",33554432,4,[[2,-265,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[34,"THÊM LƯỢT",50,50,1,false,true,-266,[0,"2frm37uaJHQr0AEEaYyM82"],30],[27,-267,[4,4289425681]],[28,-268,[4,4283776010],[0,0,-2]]],[1,0,230,0]],[4,"Label",33554432,16,[[2,-269,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,90]],[74,"ĐỔI LƯỢT:",0,35,35,1,false,true,-270,[0,"2frm37uaJHQr0AEEaYyM82"],31],[27,-271,[4,4289425681]],[28,-272,[4,4283776010],[0,0,-2]]],[1,-230,0,0]],[29,"ButtonMinus",33554432,16,[[[2,-273,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,54,58]],[24,1,0,-274,32],-275],4,4,1],[1,-125,0,0]],[29,"ButtonAdd",33554432,16,[[[2,-276,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,54,58]],[24,1,0,-277,33],-278],4,4,1],[1,125,0,0]],[4,"Label",33554432,26,[[2,-279,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,90]],[74,"CÒN LẠI:",0,35,35,1,false,true,-280,[0,"2frm37uaJHQr0AEEaYyM82"],35],[27,-281,[4,4289425681]],[28,-282,[4,4283776010],[0,0,-2]]],[1,-230,0,0]],[22,"ButtonClose",33554432,4,[-286],[[2,-283,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-285,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Hide",6],[8,"cc.AudioSource","play",2]],[4,4292269782],-284,45,46,47,48]],[1,0,-350,0]],[15,"Overlay",33554432,18,[[2,-287,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-288,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],49],[30,-289],[10,45,20,20,-290]]],[20,"Border",33554432,19,[-294],[[2,-291,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,450]],[31,1,0,-292,[0,"e71ctEmpxFC4KlSYRZNz/a"],50],[32,18,275,275,572,572,200,190,-293]]],[22,"ButtonClose",33554432,19,[-298],[[2,-295,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-297,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"cd786OL4KtC4rtPw+E8R6+f","Close",18],[8,"cc.AudioSource","play",2]],[4,4292269782],-296,52,53,54,55]],[1,0,-300,0]],[4,"Title",33554432,19,[[2,-299,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[34,"THÔNG BÁO",50,50,1,false,true,-300,[0,"2frm37uaJHQr0AEEaYyM82"],56],[27,-301,[4,4289425681]],[28,-302,[4,4283776010],[0,0,-2]]],[1,0,180,0]],[15,"Overlay",33554432,20,[[2,-303,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-304,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],57],[30,-305],[10,45,20,20,-306]]],[22,"Title",33554432,29,[-309,-310],[[2,-307,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,616,94]],[71,1,93,-308]],[1,0,230,0]],[89,"content",33554432,[[16,-311,[0,"99yn0cfL9MmZYfJbPmK9qL"],[5,610,610],[0,0.5,1]],[124,1,2,-312]],[1,-5,0,0]],[20,"view",33554432,30,[59],[[16,-313,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,608,500],[0,0.5,1]],[127,-314,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[119,45,4,4,240,250,1,-315]]],[22,"ButtonClose",33554432,21,[-319],[[2,-316,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-318,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"bdf99lAQSJLuJR79SBJsE50","Close",20],[8,"cc.AudioSource","play",2]],[4,4292269782],-317,64,65,66,67]],[1,0,-450,0]],[4,"Title",33554432,21,[[2,-320,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[34,"LỊCH SỬ",50,50,1,false,true,-321,[0,"2frm37uaJHQr0AEEaYyM82"],68],[27,-322,[4,4289425681]],[28,-323,[4,4283776010],[0,0,-2]]],[1,0,325,0]],[90,"Overlay",false,33554432,11,[[2,-324,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-325,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3221225472],69],[10,45,20,20,-326]]],[20,"Background",33554432,1,[12,22],[[2,-327,[0,"f7NISe7HdAD68SLfhnddy8"],[5,1128,1500]],[23,0,-328,[0,"e71ctEmpxFC4KlSYRZNz/a"],91]]],[15,"Background",33554432,34,[[2,-329,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,64]],[26,0,-330,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,2164055946],93],[56,40,64,-331]]],[7,["7aFiDHn+NClKHPLQ2dj3zj"]],[7,["7aFiDHn+NClKHPLQ2dj3zj"]],[7,["7aFiDHn+NClKHPLQ2dj3zj"]],[25,"Light",33554432,13,[-335],[[[6,-332,[5,670,670]],[21,-333,100],-334],4,4,1],[1,0,50,0]],[20,"TurnWithoutLogin",33554432,15,[-338],[[6,-336,[5,359,182]],[10,45,100,100,-337]]],[140,"main",[-339,-340,3],[106,[]],[141,[142],[143,[4,4283190348]],[144],[145]]],[67,"Border",33554432,14,[[2,-341,[0,"f7NISe7HdAD68SLfhnddy8"],[5,694,770]],[31,1,0,-342,[0,"e71ctEmpxFC4KlSYRZNz/a"],1],[32,18,275,275,572,572,200,190,-343]],[1,0.9,0.9,0.9]],[67,"Border",33554432,10,[[2,-344,[0,"f7NISe7HdAD68SLfhnddy8"],[5,694,636]],[31,1,0,-345,[0,"e71ctEmpxFC4KlSYRZNz/a"],12],[32,18,275,275,572,572,200,190,-346]],[1,0.9,0.9,0.8]],[4,"Label",33554432,24,[[2,-347,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,105]],[34,"Chia sẻ với bạn bè",25,25,1,false,true,-348,[0,"2frm37uaJHQr0AEEaYyM82"],19],[42,45,5,42.26,50.4,-349]],[1,0,2.5,0]],[53,"Particle",false,33554432,5,[[-350,[2,-351,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-352,[0,"50bRhRSqFKc4o+eXu3VyY/"]]],1,4,4],[1,0,-780,0],[1,50,50,50]],[15,"Border",33554432,4,[[2,-353,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,550]],[31,1,0,-354,[0,"e71ctEmpxFC4KlSYRZNz/a"],29],[32,18,275,275,572,572,200,190,-355]]],[4,"Label",33554432,28,[[2,-356,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,105]],[34,"Xác Nhận",25,25,1,false,true,-357,[0,"2frm37uaJHQr0AEEaYyM82"],38],[42,45,5,42.26,50.4,-358]],[1,0,2.5,0]],[4,"Label",33554432,17,[[2,-359,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,75]],[34,"Chia sẻ",25,25,1,false,true,-360,[0,"2frm37uaJHQr0AEEaYyM82"],40],[42,45,35,42.26,50.4,-361]],[1,0,17.5,0]],[4,"Label-001",33554432,17,[[2,-362,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,50.4]],[132,"Nhận thêm lượt chơi miển phí",15,15,1,false,true,-363,[0,"2frm37uaJHQr0AEEaYyM82"],[4,3036676095],41],[73,41,38.937,47.3,42.26,50.4,-364]],[1,0,-9.136999999999997,0]],[29,"Message",33554432,54,[[[2,-365,[0,"c68UOAlNhN171Umca6yVvF"],[5,564,320]],-366,[120,45,30,30,100,30,600,500,1,-367]],4,1,4],[1,0,-35,0]],[20,"Container",33554432,58,[-369,-370],[[2,-368,[0,"3242DVCWtMepBNxixN/wo6"],[5,616,94]]]],[7,["b2fdGMTRlIcIXQiFGMJj1n"]],[4,"Item1",33554432,22,[[2,-371,[0,"f7NISe7HdAD68SLfhnddy8"],[5,178,139]],[41,-372,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3238002687],87]],[1,-226.881,346.545,0]],[68,"Item2",33554432,22,[[2,-373,[0,"f7NISe7HdAD68SLfhnddy8"],[5,124,121]],[41,-374,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3238002687],88]],[1,251.767,612.541,0],[3,0,0,0.49999999999999994,0.8660254037844387],[1,0.8,0.8,0.8],[1,0,0,60]],[91,"Item3",33554432,22,[[2,-375,[0,"f7NISe7HdAD68SLfhnddy8"],[5,124,121]],[41,-376,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1090519039],89]],[1,-204.778,429.592,0],[1,0.5,0.5,0.5]],[68,"Item4",33554432,22,[[2,-377,[0,"f7NISe7HdAD68SLfhnddy8"],[5,178,139]],[41,-378,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1090519039],90]],[1,236.11,318.119,0],[3,0,0,0.49999999999999994,0.8660254037844387],[1,0.3,0.3,0.5],[1,0,0,60]],[101,"Overlay",false,33554432,13,[[[2,-379,[0,"f7NISe7HdAD68SLfhnddy8"],[5,1128,1500]],-380,[30,-381]],4,1,4]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[4,"Label",33554432,36,[[2,-382,[0,"07QMd0h1dLcYd/vjigaip6"],[5,359,100]],[75,"QUAY",60,60,1,false,false,true,-383,[0,"ee3IZdy2dLIaAWpjI7P0FL"],110],[73,45,17,65,100,40,-384]],[1,0,24,0]],[4,"Label",33554432,70,[[2,-385,[0,"07QMd0h1dLcYd/vjigaip6"],[5,359,162]],[75,"QUAY",60,60,1,false,false,true,-386,[0,"ee3IZdy2dLIaAWpjI7P0FL"],111],[42,45,20,100,40,-387]],[1,0,10,0]],[102,"ConfettiDrop",33554432,1,[[-388,[2,-389,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-390,[0,"50bRhRSqFKc4o+eXu3VyY/"]]],1,4,4],[1,0,760,0],[1,50,50,50]],[92,"GameMgr","cfnugoLNRBn4krmo0no0Tq",71,[-400],[[146,-399,-398,-397,-396,-395,-394,-393,-392,-391]]],[93,"Audios",98,[2],[[147,true,-401]]],[15,"Icon",33554432,40,[[2,-402,[0,"f7NISe7HdAD68SLfhnddy8"],[5,50,50]],[23,0,-403,[0,"e71ctEmpxFC4KlSYRZNz/a"],6]]],[39,"GiftIcon",33554432,10,[[[2,-404,[0,"f7NISe7HdAD68SLfhnddy8"],[5,300,300]],-405],4,1]],[15,"Icon",33554432,43,[[2,-406,[0,"f7NISe7HdAD68SLfhnddy8"],[5,50,50]],[23,0,-407,[0,"e71ctEmpxFC4KlSYRZNz/a"],14]]],[57,false,false,44,[0,"0b7a7v3FVOCpzmec7amMlB"],[[22,null],6,0],[14],[9,1],[1],[1],[5,3,40,70],[1],[1],[5,3,-3.141592653589793,6.283185307179586],[1],[5,3,2,3],[9,5],[1],[1],[[59,0.01,[9,20]]],[46,[14]],[60,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,-7.5]],[47,true,[58,1,-409],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[61,true,[5,3,0.3,-0.3],[5,3,0.3,-0.3],[5,3,0.3,-0.3]],[62,true,0.21,[1],[1],[1],[5,3,0.5,1]],[49,true,[1],[1],[5,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[14],[14],-408],[52,23]],[77,2,8,[[78,1],[63,0.78,1],[154,0.99]]],[57,false,false,75,[0,"0b7a7v3FVOCpzmec7amMlB"],[[24,null],6,0],[14],[9,1],[1],[1],[5,3,40,70],[1],[1],[5,3,-3.141592653589793,6.283185307179586],[1],[5,3,2,3],[9,5],[1],[1],[[59,0.01,[9,20]]],[46,[14]],[60,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,0]],[47,true,[58,1,104],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[61,true,[5,3,0.3,-0.3],[5,3,0.3,-0.3],[5,3,0.3,-0.3]],[62,true,0.21,[1],[1],[1],[5,3,0.5,1]],[49,true,[1],[1],[5,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[14],[14],-410],[52,25]],[57,false,false,45,[0,"0b7a7v3FVOCpzmec7amMlB"],[[26,null],6,0],[14],[9,1],[1],[1],[5,3,40,70],[1],[1],[5,3,-3.141592653589793,6.283185307179586],[1],[5,3,2,3],[9,5],[1],[1],[[59,0.01,[9,20]]],[46,[14]],[60,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,7.5]],[47,true,[58,1,104],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[61,true,[5,3,0.3,-0.3],[5,3,0.3,-0.3],[5,3,0.3,-0.3]],[62,true,0.21,[1],[1],[1],[5,3,0.5,1]],[49,true,[1],[1],[5,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[14],[14],-411],[52,27]],[29,"RateHint",33554432,4,[[[2,-412,[0,"c68UOAlNhN171Umca6yVvF"],[5,315,25]],-413],4,1],[1,100.359,150,0]],[4,"Coin",33554432,26,[[2,-414,[0,"f7NISe7HdAD68SLfhnddy8"],[5,45,45]],[23,0,-415,[0,"e71ctEmpxFC4KlSYRZNz/a"],36]],[1,120,0,0]],[15,"Icon",33554432,52,[[2,-416,[0,"f7NISe7HdAD68SLfhnddy8"],[5,50,50]],[23,0,-417,[0,"e71ctEmpxFC4KlSYRZNz/a"],44]]],[15,"Icon",33554432,55,[[2,-418,[0,"f7NISe7HdAD68SLfhnddy8"],[5,50,50]],[23,0,-419,[0,"e71ctEmpxFC4KlSYRZNz/a"],51]]],[15,"Bg",33554432,58,[[2,-420,[0,"f7NISe7HdAD68SLfhnddy8"],[5,616,94]],[26,0,-421,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294965740],58]]],[4,"Name",33554432,81,[[16,-422,[0,"c68UOAlNhN171Umca6yVvF"],[5,450,94],[0,0,0.5]],[133,"QUÀ NHẬN ĐƯỢC",0,30,30,30,1,false,false,true,-423,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],59]],[1,-280,0,0]],[4,"Time",33554432,81,[[16,-424,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,94],[0,0,0.5]],[134,"NGÀY",0,30,30,30,1,false,true,-425,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],60]],[1,200,0,0]],[29,"bar",33554432,31,[[[16,-426,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,3,156.25],[0,0,0]],-427],4,1],[1,-4,-31.25,0]],[15,"Icon",33554432,61,[[2,-428,[0,"f7NISe7HdAD68SLfhnddy8"],[5,50,50]],[23,0,-429,[0,"e71ctEmpxFC4KlSYRZNz/a"],63]]],[4,"MyTour",33554432,11,[[6,-430,[5,242,57]],[21,-431,70]],[1,0,45,0]],[4,"Dot1",33554432,7,[[6,-432,[5,13,17]],[21,-433,71]],[1,-63.5,0,0]],[4,"Dot2",33554432,7,[[6,-434,[5,13,17]],[21,-435,72]],[1,-45.5,0,0]],[4,"Dot3",33554432,7,[[6,-436,[5,13,17]],[21,-437,73]],[1,-27.5,0,0]],[4,"Dot4",33554432,7,[[6,-438,[5,13,17]],[21,-439,74]],[1,-9.5,0,0]],[4,"Dot5",33554432,7,[[6,-440,[5,13,17]],[21,-441,75]],[1,8.5,0,0]],[4,"Dot6",33554432,7,[[6,-442,[5,13,17]],[21,-443,76]],[1,26.5,0,0]],[4,"Dot7",33554432,7,[[6,-444,[5,13,17]],[21,-445,77]],[1,44.5,0,0]],[4,"Dot8",33554432,7,[[6,-446,[5,13,17]],[21,-447,78]],[1,62.5,0,0]],[4,"DogBig",33554432,11,[[6,-448,[5,55,55]],[21,-449,79]],[1,-60,0,0]],[15,"Icon",33554432,32,[[2,-450,[0,"f7NISe7HdAD68SLfhnddy8"],[5,48,73]],[23,0,-451,[0,"e71ctEmpxFC4KlSYRZNz/a"],82]]],[12,12,[13,"b2fdGMTRlIcIXQiFGMJj1n",-452,[155,"5aeUzVRlFJQZwGUuPvpQPa",null,[[156,[null],[7,["b2fdGMTRlIcIXQiFGMJj1n"]]]],[[157,"Light1",["_name"],[7,["b2fdGMTRlIcIXQiFGMJj1n"]]],[19,["_lpos"],[7,["b2fdGMTRlIcIXQiFGMJj1n"]],[1,-350,-900,0]],[19,["_lrot"],[7,["b2fdGMTRlIcIXQiFGMJj1n"]],[3,0,0,0,1]],[19,["_euler"],[7,["b2fdGMTRlIcIXQiFGMJj1n"]],[1,0,0,0]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]],[19,["_fillCenter"],[7,["e71ctEmpxFC4KlSYRZNz/a"]],[0,0.5,0]]]],83]],[12,12,[13,"b2fdGMTRlIcIXQiFGMJj1n",-453,[17,"daVT4GV0pP97P9rhpgvSx7",[[11,"Light2",["_name"],82],[3,["_lpos"],82,[1,-100,-900,0]],[3,["_lrot"],82,[3,0,0,0,1]],[3,["_euler"],82,[1,0,0,0]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],84]],[12,12,[13,"b2fdGMTRlIcIXQiFGMJj1n",-457,[17,"f0nuBd9YdH6qRKlBur5gXY",[[11,"Light3",["_name"],-454],[3,["_lpos"],-455,[1,100,-900,0]],[3,["_lrot"],-456,[3,0,0,0,1]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],85]],[7,["b2fdGMTRlIcIXQiFGMJj1n"]],[12,12,[13,"b2fdGMTRlIcIXQiFGMJj1n",-461,[17,"33B3OWAiVASJNK8464HR5/",[[11,"Light4",["_name"],-458],[3,["_lpos"],-459,[1,350,-900,0]],[3,["_lrot"],-460,[3,0,0,0,1]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],86]],[7,["b2fdGMTRlIcIXQiFGMJj1n"]],[15,"Icon",33554432,33,[[2,-462,[0,"f7NISe7HdAD68SLfhnddy8"],[5,122,141]],[23,0,-463,[0,"e71ctEmpxFC4KlSYRZNz/a"],92]]],[29,"Text",33554432,34,[[[16,-464,[0,"c68UOAlNhN171Umca6yVvF"],[5,32.13,50.4],[0,0,0.5]],-465],4,1],[1,-375,0,0]],[12,23,[13,"7aFiDHn+NClKHPLQ2dj3zj",-466,[17,"326+nkc0hO36x0TSXjkFcL",[[11,"ItemNotification",["name"],66],[3,["rotation"],66,[3,0,0,0,1]],[11,"ItemNotification",["_name"],66],[3,["_lpos"],66,[1,0,135,0]],[3,["_lrot"],66,[3,0,0,0,1]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],94]],[12,23,[13,"7aFiDHn+NClKHPLQ2dj3zj",-467,[17,"69Qvi4tOZGkZcPQ4lkWdQ1",[[11,"ItemNotification",["name"],67],[3,["rotation"],67,[3,0,0,0,1]],[11,"ItemNotification",["_name"],67],[3,["_lpos"],67,[1,0,90,0]],[3,["_lrot"],67,[3,0,0,0,1]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],95]],[12,23,[13,"7aFiDHn+NClKHPLQ2dj3zj",-468,[17,"d4nlBWj2hLWK7bsk3BLsoA",[[11,"ItemNotification",["name"],68],[3,["rotation"],68,[3,0,0,0,1]],[11,"ItemNotification",["_name"],68],[3,["_lpos"],68,[1,0,45,0]],[3,["_lrot"],68,[3,0,0,0,1]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],96]],[12,23,[13,"7aFiDHn+NClKHPLQ2dj3zj",-469,[17,"71mBAiiERGEb8A2EprXYvV",[[11,"ItemNotification",["name"],35],[3,["position"],35,[1,0,0,0]],[3,["rotation"],35,[3,0,0,0,1]],[11,"ItemNotification",["_name"],35],[3,["_lpos"],35,[1,0,0,0]],[3,["_lrot"],35,[3,0,0,0,1]],[19,["_anchorPoint"],[7,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],97]],[4,"Base",33554432,13,[[2,-470,[0,"f7NISe7HdAD68SLfhnddy8"],[5,892,486]],[36,-471,[0,"e71ctEmpxFC4KlSYRZNz/a"],98]],[1,0,-370,0]],[4,"Spin",33554432,13,[[2,-472,[0,"f7NISe7HdAD68SLfhnddy8"],[5,640,640]],[36,-473,[0,"e71ctEmpxFC4KlSYRZNz/a"],99]],[1,0,50,0]],[39,"On",33554432,69,[[[6,-474,[5,710,710]],-475],4,1]],[4,"Gift",33554432,13,[[2,-476,[0,"f7NISe7HdAD68SLfhnddy8"],[5,653,250]],[36,-477,[0,"e71ctEmpxFC4KlSYRZNz/a"],101]],[1,19,-350,0]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-481,[17,"b2bNXMqyhFFbm3cJdMADUT",[[11,"ItemSpin1",["_name"],-478],[3,["_lpos"],-479,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],-480,[3,0,0,0,1]]]],102]],[7,["3empOM9gJKLaiwBBtK/4Le"]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-482,[17,"eftggHp71N6Id3jQvnV4Yp",[[11,"ItemSpin2",["_name"],88],[3,["_lpos"],88,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],88,[3,0,0,-0.3826834323650898,0.9238795325112867]],[3,["_euler"],88,[1,0,0,-45]]]],103]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-483,[17,"39XwOZJJNP55MRXiDBChDX",[[11,"ItemSpin3",["_name"],89],[3,["_lpos"],89,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],89,[3,0,0,-0.7071067811865475,0.7071067811865476]],[3,["_euler"],89,[1,0,0,-90]]]],104]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-484,[17,"0d2xPjlcFJbbKm1VRlcDLy",[[11,"ItemSpin4",["_name"],90],[3,["_lpos"],90,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],90,[3,0,0,-0.9238795325112867,0.38268343236508984]],[3,["_euler"],90,[1,0,0,-135]]]],105]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-485,[17,"562/uFHnlHXrCSaKh9Uy5K",[[11,"ItemSpin5",["_name"],91],[3,["_lpos"],91,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],91,[3,0,0,-1,6.123233995736766e-17]],[3,["_euler"],91,[1,0,0,-180]]]],106]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-486,[17,"f2xbVz3mlJT7Wwb78K2U7D",[[11,"ItemSpin6",["_name"],92],[3,["_lpos"],92,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],92,[3,0,0,-0.9238795325112867,-0.3826834323650897]],[3,["_euler"],92,[1,0,0,-225]]]],107]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-487,[17,"1cFJ9NhTpHUJJoAGMtCJqr",[[11,"ItemSpin7",["_name"],93],[3,["_lpos"],93,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],93,[3,0,0,-0.7071067811865476,-0.7071067811865475]],[3,["_euler"],93,[1,0,0,-270]]]],108]],[12,8,[13,"3empOM9gJKLaiwBBtK/4Le",-488,[17,"08vKO/zSRCmIAurg4s7VOs",[[11,"ItemSpin8",["_name"],94],[3,["_lpos"],94,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],94,[3,0,0,-0.3826834323650899,-0.9238795325112867]],[3,["_euler"],94,[1,0,0,-315]]]],109]],[29,"Turns",33554432,36,[[[2,-489,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,177.67000000000002,50.4]],-490],4,1],[1,0,-35,0]],[4,"Logo",33554432,1,[[2,-491,[0,"f7NISe7HdAD68SLfhnddy8"],[5,585,197]],[23,0,-492,[0,"e71ctEmpxFC4KlSYRZNz/a"],113]],[1,0,490,0]],[149,1000,97,[0,"0b7a7v3FVOCpzmec7amMlB"],[[114,null],6,0],[14],[9,0.75],[1],[1],[9,-0.1],[1],[1],[5,3,-3.141592653589793,6.283185307179586],[1],[5,3,5,10],[9,0.1],[9,5],[1],[46,[14]],[151,true,0,0.01,0.20943951023931956,[9,1],[1,25,0.2,25]],[47,true,[150,1,[77,2,8,[[78,1],[63,0.69,1],[63,1,-0.01]]]],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[152,[5,3,0.3,-0.3],[5,3,0.3,-0.3],[5,3,0.3,-0.3]],[153,0.21,[1],[1],[1],[5,3,0.5,1]],[49,true,[1],[1],[5,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[14],[14],-493],[52,115]],[94,"Main Camera","c9DMICJLFO5IeO07EPon7U",71,[[158,1822425087,-494,[4,4284690175]]],[1,-10,10,10],[3,-0.27781593346944056,-0.36497167621709875,-0.11507512748638377,0.8811195706053617],[1,-35,-45,0]],[148,false,2],[160,1,36,70,154],[104,"Camera",3,[-495],[1,0,0,1000]],[159,0,1073741824,750,2000,6,41943040,158,[4,4284690175]],[161,9,14],[40,0,101,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[162,5,10,161,[103,105,106]],[76,"5",50,50,1,false,25,[0,"2frm37uaJHQr0AEEaYyM82"]],[33,3,0.9,49,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Minus",6],[8,"cc.AudioSource","play",2]],[4,4292269782],49],[33,3,0.9,50,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Add",6],[8,"cc.AudioSource","play",2]],[4,4292269782],50],[135,"(100 xu cho mỗi lượt chơi)",2,18,18,20,1,true,107,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284690175]],[76,"5",50,50,1,false,27,[0,"2frm37uaJHQr0AEEaYyM82"]],[33,3,0.9,28,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Exchange",6],[8,"cc.AudioSource","play",2]],[4,4292269782],28],[163,6,4,164,165,168,163,167,166],[136,"Error here",30,30,1,false,80,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4283914071]],[164,18,19,170],[110,1,0,114,[0,"02Vchn8fFF/77B+7pVCQuQ"],[4,4284888063]],[165,1,31,[0,"f4i77UV0dH4pcD0KQOXx7c"],172],[166,0.23,0.75,false,30,[0,"a8UaPDxYhIX5MrqvKGMJdR"],59,173],[167,20,21,59],[168,11,63],[33,3,0.9,32,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","Exit",1]],[4,4292269782],32],[33,3,0.9,33,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","History",1]],[4,4292269782],33],[137,"Text",0,18,18,false,true,134,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4282335039]],[169,34,65,179],[111,0,87,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,0]],[112,3,2,141,[0,0.5,0.5]],[170,69,182],[171,13,183,[143,145,146,147,148,149,150,151]],[172,"<color=#0b3b59>Còn lại</color><color=#ff245f> 0 </color><color=#0b3b59>lượt</color>",1,28,false,152,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[33,3,0.9,15,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","Spin",1]],[4,4292269782],15]],0,[0,0,1,0,-2,157,0,0,1,0,-1,64,0,-2,33,0,-3,34,0,-4,23,0,-5,13,0,-6,15,0,-7,153,0,-8,97,0,-1,156,0,0,3,0,21,159,0,0,3,0,0,3,0,-1,158,0,-3,9,0,-4,5,0,-5,6,0,-6,18,0,-7,20,0,-8,11,0,-9,32,0,0,4,0,0,4,0,-1,76,0,-2,47,0,-3,16,0,-4,107,0,-5,26,0,-6,28,0,-7,17,0,-8,52,0,0,5,0,0,5,0,-3,162,0,-1,41,0,-2,10,0,-3,44,0,-4,75,0,-5,45,0,0,6,0,-2,169,0,0,6,0,-1,46,0,0,7,0,0,7,0,-1,117,0,-2,118,0,-3,119,0,-4,120,0,-5,121,0,-6,122,0,-7,123,0,-8,124,0,0,8,0,-1,143,0,-2,145,0,-3,146,0,-4,147,0,-5,148,0,-6,149,0,-7,150,0,-8,151,0,0,9,0,0,9,0,-3,160,0,-1,37,0,-2,14,0,0,10,0,0,10,0,-1,73,0,-2,42,0,-3,101,0,-4,43,0,-5,24,0,0,11,0,0,11,0,0,11,0,-4,176,0,-1,63,0,-2,116,0,-4,125,0,0,12,0,0,12,0,0,12,0,-1,127,0,-2,128,0,-3,129,0,-4,131,0,0,12,0,-1,127,0,-2,128,0,-3,129,0,-4,131,0,0,13,0,-2,184,0,-1,139,0,-2,140,0,-3,87,0,-4,69,0,-5,142,0,0,14,0,0,14,0,-1,72,0,-2,38,0,-3,39,0,-4,40,0,0,15,0,0,15,0,-3,186,0,0,15,0,-1,36,0,-2,70,0,0,16,0,0,16,0,-1,48,0,-2,25,0,-3,49,0,-4,50,0,0,17,0,0,17,0,7,17,0,0,17,0,-1,78,0,-2,79,0,0,18,0,0,18,0,-3,171,0,-1,53,0,-2,19,0,0,19,0,0,19,0,-1,54,0,-2,55,0,-3,56,0,0,20,0,0,20,0,-3,175,0,-1,57,0,-2,21,0,0,21,0,0,21,0,-1,29,0,-2,61,0,-3,62,0,0,22,0,-1,83,0,-2,84,0,-3,85,0,-4,86,0,0,22,0,-1,83,0,-2,84,0,-3,85,0,-4,86,0,0,23,0,22,180,0,-1,135,0,-2,136,0,-3,137,0,-4,138,0,0,23,0,-1,135,0,-2,136,0,-3,137,0,-4,138,0,0,24,0,0,24,0,7,24,0,0,24,0,-1,74,0,0,25,0,-2,163,0,0,25,0,0,25,0,0,25,0,0,26,0,0,26,0,-1,51,0,-2,27,0,-3,108,0,0,27,0,-2,167,0,0,27,0,0,27,0,0,27,0,0,28,0,0,28,0,-3,168,0,-1,77,0,0,29,0,0,29,0,0,29,0,-1,58,0,-2,30,0,0,30,0,-2,174,0,0,30,0,-1,31,0,-2,60,0,0,31,0,0,31,0,0,31,0,-4,173,0,-1,114,0,0,32,0,-2,177,0,0,32,0,-1,126,0,0,33,0,-2,178,0,0,33,0,-1,133,0,0,34,0,-2,180,0,0,34,0,-1,65,0,-2,134,0,0,36,0,0,36,0,-1,95,0,-2,152,0,0,37,0,0,37,0,0,37,0,0,37,0,0,38,0,0,38,0,7,38,0,0,38,0,0,39,0,0,39,0,7,39,0,0,39,0,0,40,0,7,40,0,0,40,0,-1,100,0,0,41,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,42,0,0,43,0,7,43,0,0,43,0,-1,102,0,-1,103,0,0,44,0,0,44,0,0,44,0,-1,106,0,0,45,0,0,45,0,0,45,0,0,46,0,0,46,0,0,46,0,0,46,0,0,47,0,0,47,0,0,47,0,0,47,0,0,48,0,0,48,0,0,48,0,0,48,0,0,49,0,0,49,0,-3,164,0,0,50,0,0,50,0,-3,165,0,0,51,0,0,51,0,0,51,0,0,51,0,0,52,0,7,52,0,0,52,0,-1,109,0,0,53,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,-1,80,0,0,55,0,7,55,0,0,55,0,-1,110,0,0,56,0,0,56,0,0,56,0,0,56,0,0,57,0,0,57,0,0,57,0,0,57,0,0,58,0,0,58,0,-1,111,0,-2,81,0,0,59,0,0,59,0,0,60,0,0,60,0,0,60,0,0,61,0,7,61,0,0,61,0,-1,115,0,0,62,0,0,62,0,0,62,0,0,62,0,0,63,0,0,63,0,0,63,0,0,64,0,0,64,0,0,65,0,0,65,0,0,65,0,0,69,0,0,69,0,-3,183,0,-1,141,0,0,70,0,0,70,0,-1,96,0,-1,155,0,-2,98,0,0,72,0,0,72,0,0,72,0,0,73,0,0,73,0,0,73,0,0,74,0,0,74,0,0,74,0,-1,105,0,0,75,0,0,75,0,0,76,0,0,76,0,0,76,0,0,77,0,0,77,0,0,77,0,0,78,0,0,78,0,0,78,0,0,79,0,0,79,0,0,79,0,0,80,0,-2,170,0,0,80,0,0,81,0,-1,112,0,-2,113,0,0,83,0,0,83,0,0,84,0,0,84,0,0,85,0,0,85,0,0,86,0,0,86,0,0,87,0,-2,181,0,0,87,0,0,95,0,0,95,0,0,95,0,0,96,0,0,96,0,0,96,0,-1,154,0,0,97,0,0,97,0,23,156,0,24,175,0,25,169,0,26,162,0,27,160,0,28,171,0,29,176,0,30,157,0,0,98,0,-1,99,0,0,99,0,0,100,0,0,100,0,0,101,0,-2,161,0,0,102,0,0,102,0,14,103,0,31,104,0,14,105,0,14,106,0,0,107,0,-2,166,0,0,108,0,0,108,0,0,109,0,0,109,0,0,110,0,0,110,0,0,111,0,0,111,0,0,112,0,0,112,0,0,113,0,0,113,0,0,114,0,-2,172,0,0,115,0,0,115,0,0,116,0,0,116,0,0,117,0,0,117,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,121,0,0,121,0,0,122,0,0,122,0,0,123,0,0,123,0,0,124,0,0,124,0,0,125,0,0,125,0,0,126,0,0,126,0,4,127,0,4,128,0,8,130,0,8,130,0,8,130,0,4,129,0,8,132,0,8,132,0,8,132,0,4,131,0,0,133,0,0,133,0,0,134,0,-2,179,0,4,135,0,4,136,0,4,137,0,4,138,0,0,139,0,0,139,0,0,140,0,0,140,0,0,141,0,-2,182,0,0,142,0,0,142,0,8,144,0,8,144,0,8,144,0,4,143,0,4,145,0,4,146,0,4,147,0,4,148,0,4,149,0,4,150,0,4,151,0,0,152,0,-2,185,0,0,153,0,0,153,0,14,154,0,0,155,0,-1,159,0,32,71,1,9,3,2,9,99,3,9,71,4,9,6,7,9,11,8,9,13,12,9,64,22,9,64,59,9,60,157,33,177,157,34,178,157,35,186,157,36,185,157,37,181,157,38,184,173,39,174,495],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,156,163,164,165,167,168,170,172,175,177,178,179,181,182,185,185,186,157,157],[1,1,1,6,1,6,1,6,10,11,12,1,1,3,1,6,10,11,12,3,1,6,-1,15,-1,15,-1,15,1,1,3,3,1,1,1,3,1,1,3,1,3,3,1,6,1,6,10,11,12,1,1,1,6,10,11,12,3,1,1,3,3,1,1,1,6,10,11,12,3,1,1,1,1,1,1,1,1,1,1,1,-1,40,1,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,3,3,1,1,-1,15,41,3,6,6,3,6,3,1,42,6,6,3,1,1,3,43,6,44,45],[1,32,18,18,19,19,9,3,3,10,11,1,13,4,9,3,3,10,11,2,7,7,14,8,14,8,14,8,1,13,4,4,20,21,22,4,33,22,2,7,2,2,7,7,9,3,3,10,11,1,13,9,3,3,10,11,4,1,1,2,2,1,13,9,3,3,10,11,4,1,34,5,5,5,5,5,5,5,5,35,23,23,36,15,15,15,15,24,25,25,24,37,38,1,16,16,16,16,39,40,41,42,6,6,6,6,6,6,6,6,4,4,17,43,14,8,44,4,20,21,4,7,2,1,45,1,1,2,1,46,2,2,17,17,47]],[[{"name":"logo_vongquaymytour","rect":{"x":901,"y":1765,"width":585,"height":197},"offset":{"x":0,"y":0},"originalSize":{"width":585,"height":197},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"app_download","rect":{"x":1137,"y":3,"width":693,"height":728},"offset":{"x":0,"y":0},"originalSize":{"width":693,"height":728},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[174,"button_tap",".mp3",1.285063]],0,0,[],[],[]],[[{"name":"gift_front","rect":{"x":901,"y":1509,"width":653,"height":250},"offset":{"x":0,"y":0},"originalSize":{"width":653,"height":250},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"popup","rect":{"x":1857,"y":1641,"width":218,"height":165},"offset":{"x":0,"y":0},"originalSize":{"width":218,"height":165},"rotated":true,"capInsets":[80,100,95,55],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[38,"ItemGift"],[65,"ItemGift",33554432,[-8,-9],[[2,-2,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,616,122]],[175,-7,[0,"15V6KItCJGAIu1qnMu7KxT"],-6,-5,-4,-3]],[18,"80oVypFg9Ea5rK9ZuAfYlh",-1,0],[1,0,-141,0]],[95,"Container",33554432,1,[-11,-12,-13],[[2,-10,[0,"3242DVCWtMepBNxixN/wo6"],[5,616,122]]],[18,"2cAB3vm0dMyI7ZFgt7HE8v",1,0]],[69,"Bg",33554432,1,[[[2,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,616,122]],-15],4,1],[18,"a8OMyFqFRGBqO1fu7Q0rmJ",1,0]],[54,"Icon",33554432,2,[[[2,-16,[0,"f7NISe7HdAD68SLfhnddy8"],[5,185,179]],-17],4,1],[18,"74ncfWgRxBVqtM2PvgcJT2",1,0],[1,-225,0,0]],[54,"RichText",33554432,2,[[[16,-18,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,320,25.2],[0,0,0.5]],-19],4,1],[18,"aaOUBjUvJIYozcNVIzLG7q",1,0],[1,-140,0,0]],[54,"Time",33554432,2,[[[16,-20,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,94],[0,0,0.5]],-21],4,1],[18,"138ACOBEhDCJHTetcW3C00",1,0],[1,200,0,0]],[40,0,3,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[40,2,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[173,20,25,320,false,5,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[138,"02/07\n16:59",0,25,25,30,1,false,6,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488]]],0,[0,4,1,0,0,1,0,46,10,0,47,9,0,16,8,0,17,7,0,0,1,0,-1,3,0,-2,2,0,0,2,0,-1,4,0,-2,5,0,-3,6,0,0,3,0,-2,7,0,0,4,0,-2,8,0,0,5,0,-2,9,0,0,6,0,-2,10,0,13,1,21],[7,10],[1,3],[1,2]],[[{"name":"btt_spin_b","rect":{"x":1560,"y":1453,"width":359,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":359,"height":182},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"coin","rect":{"x":1621,"y":1641,"width":52,"height":52},"offset":{"x":0,"y":0},"originalSize":{"width":52,"height":52},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_lightoff","rect":{"x":3,"y":3,"width":670,"height":670},"offset":{"x":0,"y":0},"originalSize":{"width":670,"height":670},"rotated":false,"capInsets":[0,0,0,0],"texture":"199dbc35f@6c48a","packable":true}],[0],0,[0],[2],[12]],[[[176,"builtin-particle",[{"hash":1755172438,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3314483928,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3916783067,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":1118626722,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[{"name":"btt_minus","rect":{"x":1988,"y":1865,"width":54,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":58},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_back","rect":{"x":1255,"y":1968,"width":48,"height":73},"offset":{"x":0,"y":0},"originalSize":{"width":48,"height":73},"rotated":true,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[38,"ItemNotification"],[96,"ItemNotification",33554432,[-6],[[16,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,550,50],[0,0.5,0]],[31,1,0,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[177,-5,[0,"88W+AM2qdM7YL43Rm/wu6E"],-4]],[18,"7aFiDHn+NClKHPLQ2dj3zj",-1,0]],[69,"Label",33554432,1,[[[16,-7,[0,"c68UOAlNhN171Umca6yVvF"],[5,550,50],[0,0.5,0]],-8,[121,45,42.22,50.4,1,-9,[0,"cduD0aCNtBFK4RCCgUXAF2"]]],4,1,4],[18,"84yO6BiwFDMrUdCMsCSdJv",1,0]],[139,18,18,1,false,false,2,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281479730]]],0,[0,4,1,0,0,1,0,0,1,0,48,3,0,0,1,0,-1,2,0,0,2,0,-2,3,0,0,2,0,13,1,9],[0,3],[1,3],[48,2]],[[{"name":"white","rect":{"x":1406,"y":1968,"width":64,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":64,"height":64},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_loading_mytour","rect":{"x":901,"y":1968,"width":242,"height":57},"offset":{"x":0,"y":0},"originalSize":{"width":242,"height":57},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"gift_behide","rect":{"x":3,"y":1509,"width":892,"height":486},"offset":{"x":0,"y":0},"originalSize":{"width":892,"height":486},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_history","rect":{"x":1836,"y":521,"width":122,"height":141},"offset":{"x":0,"y":0},"originalSize":{"width":122,"height":141},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_bluelight","rect":{"x":365,"y":1325,"width":269,"height":309},"offset":{"x":21,"y":-3.5},"originalSize":{"width":311,"height":356},"rotated":false,"capInsets":[0,0,0,0],"texture":"199dbc35f@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"name":"luckywheel_glowlight","rect":{"x":3,"y":1325,"width":311,"height":356},"offset":{"x":0,"y":0},"originalSize":{"width":311,"height":356},"rotated":true,"capInsets":[0,0,0,0],"texture":"199dbc35f@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"name":"deco_voucher_2","rect":{"x":1853,"y":668,"width":124,"height":121},"offset":{"x":0,"y":0},"originalSize":{"width":124,"height":121},"rotated":true,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[178,[[179,"ShadowFlow",[[180,"ShadowStage"]]],[181,"ForwardFlow",1,[[182,"ForwardStage",[[183,["default"]],[184,true,1,["default"]]]]]]]]],0,0,[],[],[]],[[{"name":"icon_loading_dotc","rect":{"x":1560,"y":1641,"width":55,"height":55},"offset":{"x":0,"y":0},"originalSize":{"width":55,"height":55},"rotated":false,"capInsets":[0,0,0,0],"texture":"1a7468552@6c48a","packable":true}],[0],0,[0],[2],[0]]]]
