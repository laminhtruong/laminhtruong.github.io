[1,["1e69327bf@6c48a","e2uRISfu5MxLMoT+f2TEdu@f9941","51V+p7Zt1NDbMzgUVpCq0x","20g1ukYUVPvKWKBRznAKo+@f9941","88A6d07iNLSaRkaORvPaEN","69THl8CTRHe42k/C5WgHvu@f9941","7fFz8RNk5CgYDm7hmnra4/","15DyFwMQ1BgKNwJkeUufkb@f9941","836yr8qLBBH6v4l45wp2l2@6c48a","7ewTkjDxlIYYeENMA3mC8w@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","17699fa08@6c48a","969WVMeoRIt7JvKrq5OMI+","8ahMOAAftDboobZSHonVAy","e00c0trElNk4ufxzKBASLR","c3qMYD/7FOR4tU/q0feraG@f9941","22TbdrVWhCQr9E4IR1zjWB@f9941","3d53wxdQlLsoC/5P0yZ4EO@f9941","4bEmi6rDpGOotcKEFgTgh6@f9941","d7iAycONZLjbS7fvx8FdiV@f9941","3e+vAy1ttBIb5aOViD2mQQ@f9941","03qLmiB2FKNIQ/Oai3ne0+@f9941","78q26pg5hG85/QLom1Nrjp","43cxfhTEpDJJR4Qnka9AXX@f9941","fdSEV6iLpN8YQP4pqqdYeH@f9941","20g1ukYUVPvKWKBRznAKo+@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","f56i//Q3NBSKDKqlZvaT6X@f9941","f9d/1Y9BRMZpOmhT8k47aI@f9941","95EkngnxZFbYuFpsqVTaFr@6c48a","d1NGQ2rJZCcbhjH0/erZWw","a6RC7arGZOL4FuNB81yd04@f9941","21NqNxLBtJnZtpFPUfYPOZ@f9941","e8h+9K415L95FgUaVj8zBo@f9941","ffjs38++1DB5YMsnayAY1/@f9941","dcZUS9UklAh7kyBcFVt4EF@f9941","7bezKBZrJIHKAUgWC8Tw71@f9941","f2dna4OWpB0IMyk21r1ZDW@f9941","f1lA2++0VG1Zbb4N7b15sN@f9941","94PiB+3HZGyZxCnSimlYbV@f9941","d0jUsIZcVG3aQg58p2Im4i@f9941","bd2Azsv11Bx7cg+3Xqj0yM@f9941","a4vzUWXWhHMpeh9To8BQo2@f9941","b4TqwhPJpOv5osY+eFmNjc","c4WU7Oc5ZE37KJhjLUU5Ik","85DE6oKK1IG791cMZWQO5D@f9941","cbfYen60hGtLGwV4CgKzDB@f9941","6bZ2RlGdtCUbO0qSzblPgm@f9941"],["node","_spriteFrame","_textureSource","_font","root","asset","_normalSprite","_target","targetInfo","_parent","_hoverSprite","_pressedSprite","_disabledSprite","data","_particleSystem","_mainTexture","icon","bg","light","mainTexture","_effectAsset","_cameraComponent","scrollingText","audioTap","popupHistory","popupExchangeTurn","popupGift","popupWarning","popupError","loading","main","curve","scene","buttonBack","buttonHistory","buttonSpin","turns","overlay","spinner","_scrollView","_defaultClip","_clip","prefabItem","_userDefinedFont","spirteSpinNormal","spirteSpinDisable","time","description","information"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_id","_active","_components","_parent","_children","_lpos","_prefab","_lscale","_lrot","_euler"],-1,9,1,2,5,4,5,5,5],["cc.Sprite",["_sizeMode","_type","_fillType","_fillStart","_fillRange","node","__prefab","_spriteFrame","_color","_fillCenter"],-2,1,4,6,5,5],["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_top","_left","_right","_bottom","_alignMode","node","__prefab"],-5,1,4],["cc.Node",["_name","_layer","_active","_components","_parent","_lpos","_children","_prefab","_lscale","_lrot","_euler"],0,12,1,5,2,4,5,5,5],["cc.Label",["_actualFontSize","_isSystemFontUsed","_string","_overflow","_fontSize","_isBold","_horizontalAlign","_enableWrapText","_lineHeight","node","__prefab","_color","_font"],-6,1,4,5,6],"cc.ImageAsset","cc.Texture2D",["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.CurveRange",["mode","constantMax","constant","constantMin","curve"],-1,1],["cc.Button",["_transition","_zoomScale","node","__prefab","clickEvents","_normalColor","_target","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],1,1,4,9,5,1,6,6,6,6],["cc.Keyframe",["value","time"],1],["cc.Node",["_name","_components","_parent","_lpos"],2,2,1,5],["cc.PrefabInfo",["fileId","targetOverrides","root","asset"],1,1,1],["cc.Layout",["_layoutType","_spacingX","_resizeMode","node"],0,1],["cc.Mask",["node","__prefab"],3,1,4],["cc.AudioSource",["_loop","_playOnAwake","node"],1,1],["cc.ParticleSystem",["loop","playOnAwake","_capacity","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","bursts"],0,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9],["cc.ShapeModule",["_enable","radius","_angle","emitFrom","_shapeType","arcSpeed","_rotation","_scale"],-2,4,5,5],["cc.ForceOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.LimitVelocityOvertimeModule",["dampen","_enable","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents"],1,9,9],["cc.Camera",["_visibility","_projection","_priority","_orthoHeight","_far","_clearFlags","node","_color"],-3,1,5],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],["cc.TTFFont",["_name","_native"],1],["cc.AnimationClip",["_name","speed","wrapMode","_duration","_hash","_curves","_keys","_commonTargets"],-4,12],["cc.animation.HierarchyPath",["path"],2],["cc.Prefab",["_name"],2],["cc.CompPrefabInfo",["fileId"],2],["80778T/Aw5KTqtRMvdABmlf",["node","__prefab","bg","icon","light"],3,1,4,1,1,1],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.Material",["_techIdx","_states","_defines","_props"],0,12],["cc.SceneAsset",["_name"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.BlockInputEvents",["node"],3,1],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["180c9lqTTZHVpxGKnnQEokO",["node","lights"],3,1,2],["cc.ClickEvent",["_componentId","handler","target"],1,1],["59a412K1NxEW77Yknuvdy8e",["node","items"],3,1,2],["e6329fh7QdHiYn7arpg1TCs",["node","Notifications","scrollingText"],3,1,2,1],["cc.TargetInfo",["localID"],2],["cc.LabelOutline",["node","_color"],3,1,5],["cc.LabelShadow",["node","_color","_offset"],3,1,5,5],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",[],3],["2df67cPW6dPX48dJVTWAnOy",["node","main","loading","popupError","popupWarning","popupGift","popupExchangeTurn","popupHistory","audioTap"],3,1,1,1,1,1,1,1,1,1],["cc.GradientRange",[],3],["cc.CurveRange",["mode","curve"],2,4],["cc.Burst",["repeatInterval","count"],2,4],["cc.ColorOvertimeModule",["color"],3,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","cycleCount","randomRow","rowIndex","frameOverTime","startFrame"],-3,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.AnimationCurve",["preWrapMode","postWrapMode","keyFrames"],1,9],["cc.MountedComponentsInfo",["components","targetInfo"],2,4],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["418ddTz9+lC7bF5livsSJvo",["node","confettiDrop"],3,1,1],["9c69ay9pCVG/5YDrJ1oySld",["node","container"],3,1,1],["ae5e6oHii1DAp8iAq9daOTv",["node","container","gift","particleWin"],3,1,1,1,2],["b495dvYo/BJlKfocklL9tQG",["node","container","buttonMinus","buttonAdd","buttonExchange","labelTurn","labelCoin"],3,1,1,1,1,1,1,1],["cd786OL4KtC4rtPw+E8R6+f",["node","container","message"],3,1,1,1],["cc.ScrollBar",["_direction","node","__prefab","_handle"],2,1,4,1],["cc.ScrollView",["bounceDuration","brake","horizontal","node","__prefab","_content","_verticalScrollBar"],0,1,4,1,1],["bdf99lAQSJLuJR79SBJsE50",["node","container","content"],3,1,1,1],["f2b2fXBSjhBZ4KwKnXZ/HX5",["node","overlay"],3,1,1],["bf50fwUJItJvYyJzbCOdU+b",["node","background","text1","text2"],3,1,1,1,1],["729d4KJjzhGfL0qDutk2ZsF",["node","light"],3,1,1],["c86cddfDZxLm7NGiOKG8yCW",["node","light","items"],3,1,1,2],["cc.RichText",["_string","_horizontalAlign","_fontSize","_isSystemFontUsed","node","__prefab"],-1,1,4],["cc.AudioClip",["_name","_native","_duration"],0],["2ae10c7koBII5m9zSeuZOfS",["node","__prefab","bg","icon","description","time"],3,1,4,1,1,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["45db9SjQ7xMLrjPwl8puXSz",["node","__prefab","information"],3,1,4,1],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[28,0,2],[9,1],[8,0,2,1,1],[66,0,1,2,2],[9,0,3,1,4],[1,0,1,5,4,7,3],[40,0,2],[8,0,1,1],[37,0,1,2,3],[9,2,2],[3,0,1,2,8,4],[65,0,1,2,3],[1,5,8,1],[8,0,2,1,3,1],[30,0,1,2,3,2],[51,1],[1,0,1,5,4,3],[21,0,2,2],[13,0,2,3,2],[64,0,1,2,2],[2,5,7,1],[1,0,1,5,6,4,3],[1,0,1,5,6,4,7,3],[2,1,0,5,7,3],[2,0,5,6,7,2],[4,0,1,4,6,3,5,3],[2,0,5,6,8,7,2],[4,0,1,4,3,5,3],[34,0,1],[5,2,0,4,3,1,5,9,10,12,7],[2,1,0,5,6,7,3],[3,0,4,5,3,6,1,2,8,8],[10,0,1,2,3,4,5,6,3],[41,0,1,1],[42,0,1,2,1],[4,0,2,4,6,3,3],[2,5,6,7,1],[10,0,1,2,3,4,5,6,7,8,9,10,3],[27,0,2],[4,0,1,4,3,5,8,3],[2,0,5,6,2],[2,5,6,8,7,1],[10,0,1,2,3,4,5,6,7,3],[43,0,1,1],[9,0,1,3],[54,0,1],[55,0,1,2,3,4,2],[56,0,1,2,3,1],[57,0,1,2,3,2],[58,0,1,2,3,4,5,6,7,7],[59,0,1,2,3,4,1],[60,0,1],[4,0,1,4,3,3],[4,0,1,4,3,7,5,3],[8,0,1],[3,0,1,8,3],[3,0,6,1,2,8,5],[5,2,0,4,3,1,9,10,11,6],[17,0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,29,19,20,21,22,23,24,25,26,27,28,3],[9,0,4,2],[53,0,1,2],[18,0,3,1,2,5,6,5],[19,0,1,2,3,2],[20,1,0,2,3,4,5,3],[11,1,0,3],[24,0,1,3],[1,0,1,6,4,8,7,3],[1,0,1,6,4,3],[1,0,1,5,4,9,3],[1,0,1,5,4,7,10,9,11,3],[4,0,1,4,6,3,3],[4,0,1,4,3,7,3],[8,0,1,3,1],[3,0,3,8,3],[3,0,5,8,3],[3,0,3,6,1,2,8,6],[5,2,6,0,3,1,5,9,10,12,7],[5,2,6,0,4,1,5,9,10,11,7],[61,0,1,2,3],[11,0,2],[25,0,1,2,3,4,5,6,7,8],[26,0,2],[1,0,1,5,4,8,3],[1,0,1,5,4,8,7,3],[1,0,1,4,8,3],[1,0,1,2,6,4,7,4],[1,0,6,4,2],[1,0,1,6,4,7,3],[1,0,5,6,4,7,2],[1,0,1,4,7,3],[1,0,3,1,5,4,4],[1,0,1,5,4,7,9,3],[1,0,2,5,6,4,3],[1,0,5,6,4,2],[1,0,2,5,4,7,10,11,3],[1,0,1,5,6,4,8,3],[1,0,1,6,4,8,3],[4,0,1,4,3,7,5,9,10,3],[4,0,6,3,2],[4,0,2,1,4,3,4],[4,0,1,4,3,8,3],[12,0,1,2],[12,0,2,1,3,2],[29,0,1,2,3,4,1],[13,1,2],[2,1,2,0,3,4,5,6,8,9,7,6],[2,2,0,5,6,9,7,3],[2,1,0,5,6,8,7,3],[2,1,0,5,6,8,3],[2,0,5,6,8,2],[2,1,2,5,9,3],[31,0,1,2,3,4],[32,0,2],[3,0,8,9,2],[3,0,2,7,8,9,4],[3,0,4,5,3,1,8,6],[3,0,4,8,3],[3,0,4,5,1,2,7,8,7],[3,0,4,5,3,6,1,2,7,8,9],[3,0,1,2,7,8,9,5],[33,0,1,2,1],[14,0,1,3,3],[14,2,0,3,3],[35,0,1,2,3,2],[15,0,1],[15,0,1,1],[36,0,1,1],[38,0,1,1],[39,0,1,2,1],[5,2,0,3,1,5,9,10,12,6],[5,2,0,4,3,7,1,5,9,10,12,8],[5,2,6,0,4,8,3,7,1,5,9,10,11,12,10],[5,2,6,0,4,8,3,1,5,9,10,11,12,9],[5,2,6,0,4,8,3,7,1,9,10,11,9],[5,2,6,0,4,8,3,1,9,10,11,8],[5,0,4,3,7,1,9,10,11,6],[44,0,1,2,3,2],[45,0,1,2,3,1],[46,1],[47,0,1],[48,1],[49,1],[50,0,1,2,3,4,5,6,7,8,1],[16,0,2,2],[16,1,2,2],[17,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2],[52,0,1,2],[18,0,4,1,2,5,7,5],[19,1,2,3,1],[20,0,2,3,4,5,2],[11,1,2],[21,0,1,3,2,3],[62,0,1,2],[63,0,1,2,3],[22,0,6,7,2],[22,1,2,3,4,5,0,6,7,7],[67,0,1,1],[68,0,1,1],[69,0,1,2,3,1],[70,0,1,2,3,4,5,6,1],[71,0,1,2,1],[72,0,1,2,3,2],[73,0,1,2,3,4,5,6,4],[74,0,1,2,1],[75,0,1,1],[76,0,1,2,3,1],[77,0,1,1],[78,0,1,2,1],[79,0,1,2,3,4,5,5],[80,0,1,2,4],[81,0,1,2,3,4,5,1],[82,0,1,2,4],[83,0,1,2,1],[84,0,1],[85,0,1,2],[86,0,2],[87,0,1,2,3],[88,0,1,2],[23,0,2],[23,1,2,0,4]],[[[{"name":"popup_textbox","rect":{"x":1807,"y":1974,"width":60,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":60,"height":66},"rotated":false,"capInsets":[20,20,20,20],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"button_pink_glow","rect":{"x":1807,"y":1467,"width":328,"height":109},"offset":{"x":0,"y":0},"originalSize":{"width":328,"height":109},"rotated":true,"capInsets":[50,45,50,45],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"fmt":"0","w":963,"h":2038}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["17699fa08"]}],[7],0,[],[],[]],[[{"fmt":"0","w":2046,"h":2048}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["1e69327bf"]}],[7],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["20g1ukYUVPvKWKBRznAKo+"]}],[7],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"20835ba4-6145-4fbc-a58a-051ce700aa3e@6c48a","packable":true}],[0],0,[0],[2],[26]],[[{"name":"popup_gift","rect":{"x":1137,"y":3,"width":693,"height":636},"offset":{"x":0,"y":0},"originalSize":{"width":693,"height":636},"rotated":true,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_spin_a","rect":{"x":1807,"y":3,"width":359,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":359,"height":182},"rotated":true,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_download_apple","rect":{"x":1922,"y":733,"width":258,"height":86},"offset":{"x":0,"y":0},"originalSize":{"width":258,"height":86},"rotated":true,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_add","rect":{"x":1940,"y":1974,"width":54,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":58},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"deco_voucher_1","rect":{"x":1560,"y":1467,"width":178,"height":139},"offset":{"x":0,"y":0},"originalSize":{"width":178,"height":139},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_download_google","rect":{"x":901,"y":1968,"width":258,"height":77},"offset":{"x":0,"y":0},"originalSize":{"width":258,"height":77},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[65,"utm-avo","utm-avo.ttf"]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["54TknWPwVPqJqeCR+Y/Czo"]}],[7],0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@6c48a","packable":true}],[0],0,[0],[2],[27]],[[{"name":"icon_loading_dota","rect":{"x":109,"y":2001,"width":13,"height":17},"offset":{"x":0,"y":0},"originalSize":{"width":17,"height":21},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"notification_bg","rect":{"x":3,"y":2001,"width":100,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":100,"height":36},"rotated":false,"capInsets":[30,0,30,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[80,"loading",2,22,1.3333333333333333,213801,[{"commonTarget":0,"modifiers":["x"],"data":{"keys":0,"values":[-63.5,-45.5,-27.5,-9.5,8.5,26.5,44.5,62.5,-63.5],"easingMethods":{"0":"constant","1":"constant","2":"constant","3":"constant","4":"constant","5":"constant","6":"constant","7":"constant","8":"constant"}}},{"commonTarget":0,"modifiers":["y"],"data":{"keys":1,"values":[],"easingMethods":{}}},{"commonTarget":0,"modifiers":["z"],"data":{"keys":2,"values":[],"easingMethods":{}}}],[[0,0.16666666666666666,0.3333333333333333,0.5,0.6666666666666666,0.8333333333333334,1,1.1666666666666667,1.3333333333333333],[],[]],[[[{},"modifiers",12,[[[81,"DogBig"],"position"],4,0]]],11]]],0,0,[],[],[]],[[{"name":"bg","rect":{"x":3,"y":3,"width":1128,"height":1500},"offset":{"x":0,"y":0},"originalSize":{"width":1128,"height":1500},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"popup_close","rect":{"x":1873,"y":1974,"width":61,"height":61},"offset":{"x":0,"y":0},"originalSize":{"width":61,"height":61},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[38,"ItemSpin"],[66,"ItemSpin",33554432,[-7,-8,-9],[[13,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,269,309],[0,0.089,0.08]],[103,-6,[0,"270UhrKwJN4Yj+pLBLmdV7"],-5,-4,-3]],[18,"3empOM9gJKLaiwBBtK/4Le",-1,0],[1,-0.3140000000000214,48.29399999999998,0]],[82,"Bg",33554432,1,[[13,-10,[0,"f7NISe7HdAD68SLfhnddy8"],[5,269,309],[0,0.089,0.08]],[36,-11,[0,"e71ctEmpxFC4KlSYRZNz/a"],0]],[18,"d5xvKmkx5H6ZYUU2PHgO4p",1,0]],[83,"Light",33554432,1,[[2,-12,[0,"f7NISe7HdAD68SLfhnddy8"],[5,311,356]],[36,-13,[0,"e71ctEmpxFC4KlSYRZNz/a"],1]],[18,"c31js76TJAZbcrJTiPU30m",1,0],[1,90.5,136.962,0]],[97,"Icon",33554432,1,[[[2,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,200,200]],-15],4,1],[18,"4e8fX8HyVOrpgIKHxs5Kac",1,0],[1,75,184,0],[3,0,0,-0.19509032201612825,0.9807852804032304],[1,0,0,-22.5]],[40,2,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]]],0,[0,4,1,0,0,1,0,18,3,0,16,5,0,17,2,0,0,1,0,-1,2,0,-2,4,0,-3,3,0,0,2,0,0,2,0,0,3,0,0,3,0,0,4,0,-2,5,0,13,1,15],[0,0],[1,1],[28,29]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["836yr8qLBBH6v4l45wp2l2"]}],[7],0,[],[],[]],[[{"name":"luckywheel_lighton","rect":{"x":3,"y":3,"width":710,"height":710},"offset":{"x":0,"y":0},"originalSize":{"width":710,"height":710},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[[65,"iCielPanton-Black","iCielPanton-Black.ttf"]],0,0,[],[],[]],[[[38,"Light"],[84,"Light",33554432,[[13,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,150,2000],[0,0.5,0]],[105,3,2,0,0.244,0.015,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4293983231],[0,0.5,0],0]],[18,"b2fdGMTRlIcIXQiFGMJj1n",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,13,1,3],[0],[1],[1]],[[{"name":"luckywheel_base","rect":{"x":3,"y":1395,"width":640,"height":640},"offset":{"x":0,"y":0},"originalSize":{"width":640,"height":640},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["95EkngnxZFbYuFpsqVTaFr"]}],[7],0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"951249e0-9f16-456d-8b85-a6ca954da16b@6c48a","packable":true}],[0],0,[0],[2],[30]],[[[111,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[19,20],[8,31]],[[[112,"main"],[98,"Main",[-4,-5,-6,-7,-8,-9,-10,-11],[[[7,-1,[5,750,1500]],-2,[10,45,100,100,-3]],4,1,4]],[101,"Tap",[-12]],[85,"Canvas",33554432,"0dDmbhkC9Ftb0hdJwrl+Yu",[-17,1,-18,-19,-20,-21,-22,-23,-24],[[2,-13,[0,"0dngp/9gNO34wUQjZfN/CX"],[5,750,1500]],[120,-15,[0,"3f2oTdCepERZdpmIfLsrhd"],-14],[113,45,-16,[0,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,375,750,0]],[35,"PopupGift",false,3,[-28,-29,-30,-31,-32],[[[7,-25,[5,750,1500]],[10,45,100,100,-26],-27],4,4,1]],[35,"PopupExchangeTurn",false,3,[-36,-37],[[[7,-33,[5,750,1500]],-34,[10,45,100,100,-35]],4,1,4]],[21,"Container",33554432,5,[-40,-41,-42,-43,-44,-45,-46],[[7,-38,[5,750,1500]],[10,45,100,100,-39]]],[67,"Dots",33554432,[-49,-50,-51,-52,-53,-54,-55,-56],[[7,-47,[5,140,50]],[121,1,5,-48]]],[86,"Items",[-58,-59,-60,-61,-62,-63,-64,-65],[[54,-57]]],[35,"PopupWarning",false,3,[-69,-70],[[[7,-66,[5,750,1500]],[10,45,100,100,-67],-68],4,4,1]],[21,"Container",33554432,4,[-73,-74,-75,-76,-77],[[7,-71,[5,750,1500]],[10,45,100,100,-72]]],[70,"Loading",33554432,3,[-82,-83,7,-84],[[[7,-78,[5,750,1500]],[28,-79],[123,true,-80,[79],80],-81],4,4,4,1]],[87,"Light",33554432,[-93,-94,-95,-96],[[72,-85,[5,1128,880],[0,0.5,1]],[124,-86],[55,41,100,-87],[126,-92,[-88,-89,-90,-91]]],[1,0,750,0]],[70,"Spinner",33554432,1,[-99,-100,-101,-102,-103,8],[[[54,-97],-98],4,1]],[21,"Container",33554432,9,[-106,-107,-108,-109],[[7,-104,[5,750,1500]],[10,45,100,100,-105]]],[25,"ButtonSpin",33554432,1,[-114,-115],[[[2,-110,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,359,182]],[106,2,0,-111,[0,"77BcV1zfNHo4LI4KRqZupe"],[0,0.5,0.5],110],-112,[73,1,1084,-113]],4,4,1,4],[1,0,-425,0]],[22,"Turns",33554432,6,[-118,-119,-120,-121],[[7,-116,[5,320,66]],[23,1,0,-117,34]],[1,100,100,0]],[22,"ButtonShare",33554432,6,[-126,-127],[[2,-122,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[23,1,0,-123,41],[42,3,0.9,-125,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Share",5],[8,"cc.AudioSource","play",2]],[4,4292269782],-124,42]],[1,0,-190,0]],[35,"PopupError",false,3,[-131,-132],[[[7,-128,[5,750,1500]],[10,45,100,100,-129],-130],4,4,1]],[21,"Container",33554432,18,[-135,-136,-137],[[7,-133,[5,750,1500]],[10,45,100,100,-134]]],[35,"PopupHistory",false,3,[-141,-142],[[[7,-138,[5,750,1500]],[10,45,100,100,-139],-140],4,4,1]],[21,"Container",33554432,20,[-145,-146,-147],[[7,-143,[5,750,1500]],[10,45,100,100,-144]]],[67,"Floating",33554432,[-154,-155,-156,-157],[[54,-148],[127,-153,[-149,-150,-151,-152]]]],[25,"NotificationWinner",33554432,1,[-161,-162,-163],[[[2,-158,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,50]],-159,[55,40,64,-160]],4,1,4],[1,0,625,0]],[88,"Notification",1,[-171,-172,-173,-174],[[72,-164,[5,650,135],[0,0.5,0]],[128,-170,[-166,-167,-168,-169],-165]],[1,0,-750,0]],[22,"ButtonShare",33554432,10,[-179],[[2,-175,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[23,1,0,-176,20],[42,3,0.9,-178,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"ae5e6oHii1DAp8iAq9daOTv","Share",4],[8,"cc.AudioSource","play",2]],[4,4292269782],-177,21]],[1,0,-210,0]],[25,"ButtonExchange",33554432,6,[-183],[[[2,-180,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[23,1,0,-181,38],-182],4,4,1],[1,0,-100,0]],[21,"Border",33554432,21,[-187,-188],[[2,-184,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,740]],[30,1,0,-185,[0,"e71ctEmpxFC4KlSYRZNz/a"],61],[31,18,63,63,370,370,624,760,-186]]],[25,"ScrollView",33554432,27,[-192,-193],[[[13,-189,[0,"71kmounFRG/K27WWBbH2RB"],[5,616,500],[0,0.5,1]],-190,[31,45,4,4,190,50,240,250,-191]],4,1,4],[1,0,180,0]],[25,"scrollBar",33554432,28,[-198],[[[13,-194,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,5,500],[0,1,0.5]],[107,1,0,-195,[0,"9dLJe/n0BKVoGauB1wT/Tc"],[4,4292861919],60],[114,37,250,1,-196,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-197],4,4,4,1],[1,308,-250,0]],[25,"ButtonBack",33554432,3,[-202],[[[2,-199,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],-200,[115,9,-35,25,50,100,-201]],4,1,4],[1,-335,625,0]],[25,"ButtonHistory",33554432,1,[-206],[[[2,-203,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,122,141]],-204,[74,32,10,-205]],4,1,4],[1,304,375,0]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[16,"Overlay",33554432,9,[[2,-207,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-208,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],0],[28,-209],[10,45,20,20,-210]]],[5,"ButtonDownloadApple",33554432,14,[[2,-211,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,258,86]],[23,1,0,-212,2],[42,3,0.9,-214,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","DownloadApple",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-213,3]],[1,0,-180,0]],[5,"ButtonDownloadGoogle",33554432,14,[[2,-215,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,258,86]],[23,1,0,-216,4],[42,3,0.9,-218,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","DownloadGoogle",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-217,5]],[1,0,-280,0]],[22,"ButtonClose",33554432,14,[-222],[[2,-219,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-221,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","Close",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-220,7,8,9,10]],[1,0,-460,0]],[16,"Overlay",33554432,4,[[2,-223,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-224,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],11],[28,-225],[10,45,20,20,-226]]],[5,"Title",33554432,10,[[2,-227,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,90]],[129,"KẾT QUẢ VÒNG QUAY",40,1,false,true,-228,[0,"2frm37uaJHQr0AEEaYyM82"],13],[33,-229,[4,4289425681]],[34,-230,[4,4283776010],[0,0,-2]]],[1,0,210,0]],[22,"ButtonClose",33554432,10,[-234],[[2,-231,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-233,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"ae5e6oHii1DAp8iAq9daOTv","Close",4],[8,"cc.AudioSource","play",2]],[4,4292269782],-232,15,16,17,18]],[1,0,-360,0]],[39,"ParticleLeft",33554432,4,[[-235,[2,-236,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[43,-237,[0,"50bRhRSqFKc4o+eXu3VyY/"]],[116,8,-20,-238]],1,4,4,4],[1,-370,-780,0],[1,50,50,50]],[39,"ParticleRight",33554432,4,[[-239,[2,-240,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[43,-241,[0,"50bRhRSqFKc4o+eXu3VyY/"]],[74,32,-20,-242]],1,4,4,4],[1,370,-780,0],[1,50,50,50]],[16,"Overlay",33554432,5,[[2,-243,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-244,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],28],[28,-245],[10,45,20,20,-246]]],[5,"Title",33554432,6,[[2,-247,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[29,"THÊM LƯỢT",50,50,1,false,true,-248,[0,"2frm37uaJHQr0AEEaYyM82"],30],[33,-249,[4,4289425681]],[34,-250,[4,4283776010],[0,0,-2]]],[1,0,230,0]],[5,"Label",33554432,16,[[2,-251,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,90]],[76,"ĐỔI LƯỢT",0,40,1,false,true,-252,[0,"2frm37uaJHQr0AEEaYyM82"],31],[33,-253,[4,4289425681]],[34,-254,[4,4283776010],[0,0,-2]]],[1,-230,0,0]],[27,"ButtonMinus",33554432,16,[[[2,-255,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,54,58]],[23,1,0,-256,32],-257],4,4,1],[1,-125,0,0]],[27,"ButtonAdd",33554432,16,[[[2,-258,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,54,58]],[23,1,0,-259,33],-260],4,4,1],[1,125,0,0]],[22,"Rate",33554432,6,[-263,-264],[[7,-261,[5,320,66]],[23,1,0,-262,36]],[1,100,10,0]],[5,"Label",33554432,47,[[2,-265,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,90]],[76,"CÒN LẠI",0,40,1,false,true,-266,[0,"2frm37uaJHQr0AEEaYyM82"],35],[33,-267,[4,4289425681]],[34,-268,[4,4283776010],[0,0,-2]]],[1,-230,0,0]],[22,"ButtonClose",33554432,6,[-272],[[2,-269,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-271,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Hide",5],[8,"cc.AudioSource","play",2]],[4,4292269782],-270,44,45,46,47]],[1,0,-350,0]],[16,"Overlay",33554432,18,[[2,-273,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-274,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],48],[28,-275],[10,45,20,20,-276]]],[21,"Border",33554432,19,[-280],[[2,-277,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,450]],[30,1,0,-278,[0,"e71ctEmpxFC4KlSYRZNz/a"],49],[31,18,275,275,572,572,200,190,-279]]],[22,"ButtonClose",33554432,19,[-284],[[2,-281,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-283,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"cd786OL4KtC4rtPw+E8R6+f","Close",18],[8,"cc.AudioSource","play",2]],[4,4292269782],-282,51,52,53,54]],[1,0,-300,0]],[5,"Title",33554432,19,[[2,-285,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[29,"THÔNG BÁO",50,50,1,false,true,-286,[0,"2frm37uaJHQr0AEEaYyM82"],55],[33,-287,[4,4289425681]],[34,-288,[4,4283776010],[0,0,-2]]],[1,0,180,0]],[16,"Overlay",33554432,20,[[2,-289,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-290,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],56],[28,-291],[10,45,20,20,-292]]],[22,"Title",33554432,27,[-295,-296],[[2,-293,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,616,94]],[73,1,93,-294]],[1,0,230,0]],[89,"content",33554432,[[13,-297,[0,"99yn0cfL9MmZYfJbPmK9qL"],[5,610,610],[0,0.5,1]],[122,1,2,-298]],[1,-5,0,0]],[21,"view",33554432,28,[56],[[13,-299,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,608,500],[0,0.5,1]],[125,-300,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[117,45,4,4,240,250,1,-301]]],[22,"ButtonClose",33554432,21,[-305],[[2,-302,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[37,3,0.9,-304,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"bdf99lAQSJLuJR79SBJsE50","Close",20],[8,"cc.AudioSource","play",2]],[4,4292269782],-303,63,64,65,66]],[1,0,-450,0]],[5,"Title",33554432,21,[[2,-306,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[29,"LỊCH SỬ",50,50,1,false,true,-307,[0,"2frm37uaJHQr0AEEaYyM82"],67],[33,-308,[4,4289425681]],[34,-309,[4,4283776010],[0,0,-2]]],[1,0,325,0]],[90,"Overlay",false,33554432,11,[[2,-310,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-311,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3221225472],68],[10,45,20,20,-312]]],[21,"Background",33554432,1,[12,22],[[2,-313,[0,"f7NISe7HdAD68SLfhnddy8"],[5,1128,1500]],[24,0,-314,[0,"e71ctEmpxFC4KlSYRZNz/a"],90]]],[16,"Background",33554432,23,[[2,-315,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,64]],[26,0,-316,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,2164055946],92],[55,40,64,-317]]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[25,"Light",33554432,13,[-321],[[[7,-318,[5,670,670]],[20,-319,99],-320],4,4,1],[1,0,50,0]],[136,"main",[-322,-323,3],[104,[]],[137,[138],[139,[4,4283190348]],[140],[141]]],[68,"Border",33554432,14,[[2,-324,[0,"f7NISe7HdAD68SLfhnddy8"],[5,694,770]],[30,1,0,-325,[0,"e71ctEmpxFC4KlSYRZNz/a"],1],[31,18,275,275,572,572,200,190,-326]],[1,0.9,0.9,0.9]],[68,"Border",33554432,10,[[2,-327,[0,"f7NISe7HdAD68SLfhnddy8"],[5,694,636]],[30,1,0,-328,[0,"e71ctEmpxFC4KlSYRZNz/a"],12],[31,18,275,275,572,572,200,190,-329]],[1,0.9,0.9,0.8]],[5,"Label",33554432,25,[[2,-330,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,105]],[29,"Chia sẻ với bạn bè",25,25,1,false,true,-331,[0,"2frm37uaJHQr0AEEaYyM82"],19],[56,45,5,42.26,50.4,-332]],[1,0,2.5,0]],[39,"Particle",33554432,4,[[-333,[2,-334,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[43,-335,[0,"50bRhRSqFKc4o+eXu3VyY/"]]],1,4,4],[1,0,-780,0],[1,50,50,50]],[16,"Border",33554432,6,[[2,-336,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,550]],[30,1,0,-337,[0,"e71ctEmpxFC4KlSYRZNz/a"],29],[31,18,275,275,572,572,200,190,-338]]],[52,"Value",33554432,16,[[[2,-339,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,66]],-340,[10,45,42.26,50.4,-341]],4,1,4]],[52,"Value",33554432,47,[[[2,-342,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,66]],-343,[10,45,42.26,50.4,-344]],4,1,4]],[5,"Label",33554432,26,[[2,-345,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,105]],[29,"Xác Nhận",25,25,1,false,true,-346,[0,"2frm37uaJHQr0AEEaYyM82"],37],[56,45,5,42.26,50.4,-347]],[1,0,2.5,0]],[5,"Label",33554432,17,[[2,-348,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,75]],[29,"Chia sẻ",25,25,1,false,true,-349,[0,"2frm37uaJHQr0AEEaYyM82"],39],[56,45,35,42.26,50.4,-350]],[1,0,17.5,0]],[5,"Label-001",33554432,17,[[2,-351,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,50.4]],[29,"Nhận thêm lượt chơi miển phí",15,15,1,false,true,-352,[0,"2frm37uaJHQr0AEEaYyM82"],40],[75,41,38.937,47.3,42.26,50.4,-353]],[1,0,-9.136999999999997,0]],[27,"Message",33554432,51,[[[2,-354,[0,"c68UOAlNhN171Umca6yVvF"],[5,564,320]],-355,[118,45,30,30,100,30,600,500,1,-356]],4,1,4],[1,0,-35,0]],[21,"Container",33554432,55,[-358,-359],[[2,-357,[0,"3242DVCWtMepBNxixN/wo6"],[5,616,94]]]],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[5,"Item1",33554432,22,[[2,-360,[0,"f7NISe7HdAD68SLfhnddy8"],[5,178,139]],[41,-361,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3238002687],86]],[1,-226.881,346.545,0]],[69,"Item2",33554432,22,[[2,-362,[0,"f7NISe7HdAD68SLfhnddy8"],[5,124,121]],[41,-363,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3238002687],87]],[1,251.767,612.541,0],[3,0,0,0.49999999999999994,0.8660254037844387],[1,0.8,0.8,0.8],[1,0,0,60]],[91,"Item3",33554432,22,[[2,-364,[0,"f7NISe7HdAD68SLfhnddy8"],[5,124,121]],[41,-365,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1090519039],88]],[1,-204.778,429.592,0],[1,0.5,0.5,0.5]],[69,"Item4",33554432,22,[[2,-366,[0,"f7NISe7HdAD68SLfhnddy8"],[5,178,139]],[41,-367,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1090519039],89]],[1,236.11,318.119,0],[3,0,0,0.49999999999999994,0.8660254037844387],[1,0.3,0.3,0.5],[1,0,0,60]],[99,"Overlay",false,33554432,13,[[[2,-368,[0,"f7NISe7HdAD68SLfhnddy8"],[5,1128,1500]],-369,[28,-370]],4,1,4]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[5,"Label",33554432,15,[[2,-371,[0,"07QMd0h1dLcYd/vjigaip6"],[5,359,100]],[130,"QUAY",60,60,1,false,false,true,-372,[0,"ee3IZdy2dLIaAWpjI7P0FL"],109],[75,45,17,65,100,40,-373]],[1,0,24,0]],[39,"ConfettiDrop",33554432,1,[[-374,[2,-375,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[43,-376,[0,"50bRhRSqFKc4o+eXu3VyY/"]]],1,4,4],[1,0,760,0],[1,50,50,50]],[92,"GameMgr","cfnugoLNRBn4krmo0no0Tq",67,[-386],[[142,-385,-384,-383,-382,-381,-380,-379,-378,-377]]],[93,"Audios",95,[2],[[143,true,-387]]],[16,"Icon",33554432,36,[[2,-388,[0,"f7NISe7HdAD68SLfhnddy8"],[5,60,60]],[24,0,-389,[0,"e71ctEmpxFC4KlSYRZNz/a"],6]]],[100,"GiftIcon",33554432,10,[[[2,-390,[0,"f7NISe7HdAD68SLfhnddy8"],[5,200,200]],-391],4,1],[1,1.5,1.5,1.5]],[16,"Icon",33554432,39,[[2,-392,[0,"f7NISe7HdAD68SLfhnddy8"],[5,60,60]],[24,0,-393,[0,"e71ctEmpxFC4KlSYRZNz/a"],14]]],[58,false,false,40,[0,"0b7a7v3FVOCpzmec7amMlB"],[[22,null],6,0],[15],[9,1],[1],[1],[4,3,40,70],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,2,3],[9,5],[1],[1],[[60,0.01,[9,20]]],[45,[15]],[61,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,-7.5]],[46,true,[59,1,-395],[1],[1],[1]],[47,[1],[1],[1],[9,1]],[62,true,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[63,true,0.21,[1],[1],[1],[4,3,0.5,1]],[48,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[49,true,3,3,1,true,1,[44,3,8],[1]],[50,[9,1],[1],[15],[15],-394],[51,23]],[78,2,8,[[79,1],[64,0.78,1],[150,0.99]]],[58,false,false,71,[0,"0b7a7v3FVOCpzmec7amMlB"],[[24,null],6,0],[15],[9,1],[1],[1],[4,3,40,70],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,2,3],[9,5],[1],[1],[[60,0.01,[9,20]]],[45,[15]],[61,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,0]],[46,true,[59,1,101],[1],[1],[1]],[47,[1],[1],[1],[9,1]],[62,true,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[63,true,0.21,[1],[1],[1],[4,3,0.5,1]],[48,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[49,true,3,3,1,true,1,[44,3,8],[1]],[50,[9,1],[1],[15],[15],-396],[51,25]],[58,false,false,41,[0,"0b7a7v3FVOCpzmec7amMlB"],[[26,null],6,0],[15],[9,1],[1],[1],[4,3,40,70],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,2,3],[9,5],[1],[1],[[60,0.01,[9,20]]],[45,[15]],[61,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,7.5]],[46,true,[59,1,101],[1],[1],[1]],[47,[1],[1],[1],[9,1]],[62,true,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[63,true,0.21,[1],[1],[1],[4,3,0.5,1]],[48,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[49,true,3,3,1,true,1,[44,3,8],[1]],[50,[9,1],[1],[15],[15],-397],[51,27]],[16,"Icon",33554432,49,[[2,-398,[0,"f7NISe7HdAD68SLfhnddy8"],[5,60,60]],[24,0,-399,[0,"e71ctEmpxFC4KlSYRZNz/a"],43]]],[16,"Icon",33554432,52,[[2,-400,[0,"f7NISe7HdAD68SLfhnddy8"],[5,60,60]],[24,0,-401,[0,"e71ctEmpxFC4KlSYRZNz/a"],50]]],[16,"Bg",33554432,55,[[2,-402,[0,"f7NISe7HdAD68SLfhnddy8"],[5,616,94]],[26,0,-403,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294965740],57]]],[5,"Name",33554432,79,[[13,-404,[0,"c68UOAlNhN171Umca6yVvF"],[5,450,94],[0,0,0.5]],[131,"QUÀ NHẬN ĐƯỢC",0,30,30,30,1,false,false,true,-405,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],58]],[1,-280,0,0]],[5,"Time",33554432,79,[[13,-406,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,94],[0,0,0.5]],[132,"NGÀY",0,30,30,30,1,false,true,-407,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],59]],[1,200,0,0]],[27,"bar",33554432,29,[[[13,-408,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,3,156.25],[0,0,0]],-409],4,1],[1,-4,-31.25,0]],[16,"Icon",33554432,58,[[2,-410,[0,"f7NISe7HdAD68SLfhnddy8"],[5,60,60]],[24,0,-411,[0,"e71ctEmpxFC4KlSYRZNz/a"],62]]],[5,"MyTour",33554432,11,[[7,-412,[5,242,57]],[20,-413,69]],[1,0,45,0]],[5,"Dot1",33554432,7,[[7,-414,[5,13,17]],[20,-415,70]],[1,-63.5,0,0]],[5,"Dot2",33554432,7,[[7,-416,[5,13,17]],[20,-417,71]],[1,-45.5,0,0]],[5,"Dot3",33554432,7,[[7,-418,[5,13,17]],[20,-419,72]],[1,-27.5,0,0]],[5,"Dot4",33554432,7,[[7,-420,[5,13,17]],[20,-421,73]],[1,-9.5,0,0]],[5,"Dot5",33554432,7,[[7,-422,[5,13,17]],[20,-423,74]],[1,8.5,0,0]],[5,"Dot6",33554432,7,[[7,-424,[5,13,17]],[20,-425,75]],[1,26.5,0,0]],[5,"Dot7",33554432,7,[[7,-426,[5,13,17]],[20,-427,76]],[1,44.5,0,0]],[5,"Dot8",33554432,7,[[7,-428,[5,13,17]],[20,-429,77]],[1,62.5,0,0]],[5,"DogBig",33554432,11,[[7,-430,[5,55,55]],[20,-431,78]],[1,-60,0,0]],[16,"Icon",33554432,30,[[2,-432,[0,"f7NISe7HdAD68SLfhnddy8"],[5,48,73]],[24,0,-433,[0,"e71ctEmpxFC4KlSYRZNz/a"],81]]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-434,[151,"5aeUzVRlFJQZwGUuPvpQPa",null,[[152,[null],[6,["b2fdGMTRlIcIXQiFGMJj1n"]]]],[[153,"Light1",["_name"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]]],[19,["_lpos"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[1,-350,-900,0]],[19,["_lrot"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[3,0,0,0,1]],[19,["_euler"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[1,0,0,0]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]],[19,["_fillCenter"],[6,["e71ctEmpxFC4KlSYRZNz/a"]],[0,0.5,0]]]],82]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-435,[17,"daVT4GV0pP97P9rhpgvSx7",[[11,"Light2",["_name"],80],[3,["_lpos"],80,[1,-100,-900,0]],[3,["_lrot"],80,[3,0,0,0,1]],[3,["_euler"],80,[1,0,0,0]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],83]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-439,[17,"f0nuBd9YdH6qRKlBur5gXY",[[11,"Light3",["_name"],-436],[3,["_lpos"],-437,[1,100,-900,0]],[3,["_lrot"],-438,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],84]],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-443,[17,"33B3OWAiVASJNK8464HR5/",[[11,"Light4",["_name"],-440],[3,["_lpos"],-441,[1,350,-900,0]],[3,["_lrot"],-442,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],85]],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[16,"Icon",33554432,31,[[2,-444,[0,"f7NISe7HdAD68SLfhnddy8"],[5,122,141]],[24,0,-445,[0,"e71ctEmpxFC4KlSYRZNz/a"],91]]],[27,"Text1",33554432,23,[[[13,-446,[0,"c68UOAlNhN171Umca6yVvF"],[5,783.19,50.4],[0,0,0.5]],-447],4,1],[1,-375,0,0]],[27,"Text2",33554432,23,[[[13,-448,[0,"c68UOAlNhN171Umca6yVvF"],[5,783.19,50.4],[0,0,0.5]],-449],4,1],[1,-375,0,0]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-450,[17,"326+nkc0hO36x0TSXjkFcL",[[11,"ItemNotification",["name"],63],[3,["rotation"],63,[3,0,0,0,1]],[11,"ItemNotification",["_name"],63],[3,["_lpos"],63,[1,0,135,0]],[3,["_lrot"],63,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],93]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-451,[17,"69Qvi4tOZGkZcPQ4lkWdQ1",[[11,"ItemNotification",["name"],64],[3,["rotation"],64,[3,0,0,0,1]],[11,"ItemNotification",["_name"],64],[3,["_lpos"],64,[1,0,90,0]],[3,["_lrot"],64,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],94]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-452,[17,"d4nlBWj2hLWK7bsk3BLsoA",[[11,"ItemNotification",["name"],65],[3,["rotation"],65,[3,0,0,0,1]],[11,"ItemNotification",["_name"],65],[3,["_lpos"],65,[1,0,45,0]],[3,["_lrot"],65,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],95]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-453,[17,"71mBAiiERGEb8A2EprXYvV",[[11,"ItemNotification",["name"],32],[3,["position"],32,[1,0,0,0]],[3,["rotation"],32,[3,0,0,0,1]],[11,"ItemNotification",["_name"],32],[3,["_lpos"],32,[1,0,0,0]],[3,["_lrot"],32,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],96]],[5,"Base",33554432,13,[[2,-454,[0,"f7NISe7HdAD68SLfhnddy8"],[5,892,486]],[36,-455,[0,"e71ctEmpxFC4KlSYRZNz/a"],97]],[1,0,-370,0]],[5,"Spin",33554432,13,[[2,-456,[0,"f7NISe7HdAD68SLfhnddy8"],[5,640,640]],[36,-457,[0,"e71ctEmpxFC4KlSYRZNz/a"],98]],[1,0,50,0]],[52,"On",33554432,66,[[[7,-458,[5,710,710]],-459],4,1]],[5,"Gift",33554432,13,[[2,-460,[0,"f7NISe7HdAD68SLfhnddy8"],[5,653,250]],[36,-461,[0,"e71ctEmpxFC4KlSYRZNz/a"],100]],[1,19,-350,0]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-465,[17,"b2bNXMqyhFFbm3cJdMADUT",[[11,"ItemSpin1",["_name"],-462],[3,["_lpos"],-463,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],-464,[3,0,0,0,1]]]],101]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-466,[17,"eftggHp71N6Id3jQvnV4Yp",[[11,"ItemSpin2",["_name"],86],[3,["_lpos"],86,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],86,[3,0,0,-0.3826834323650898,0.9238795325112867]],[3,["_euler"],86,[1,0,0,-45]]]],102]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-467,[17,"39XwOZJJNP55MRXiDBChDX",[[11,"ItemSpin3",["_name"],87],[3,["_lpos"],87,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],87,[3,0,0,-0.7071067811865475,0.7071067811865476]],[3,["_euler"],87,[1,0,0,-90]]]],103]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-468,[17,"0d2xPjlcFJbbKm1VRlcDLy",[[11,"ItemSpin4",["_name"],88],[3,["_lpos"],88,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],88,[3,0,0,-0.9238795325112867,0.38268343236508984]],[3,["_euler"],88,[1,0,0,-135]]]],104]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-469,[17,"562/uFHnlHXrCSaKh9Uy5K",[[11,"ItemSpin5",["_name"],89],[3,["_lpos"],89,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],89,[3,0,0,-1,6.123233995736766e-17]],[3,["_euler"],89,[1,0,0,-180]]]],105]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-470,[17,"f2xbVz3mlJT7Wwb78K2U7D",[[11,"ItemSpin6",["_name"],90],[3,["_lpos"],90,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],90,[3,0,0,-0.9238795325112867,-0.3826834323650897]],[3,["_euler"],90,[1,0,0,-225]]]],106]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-471,[17,"1cFJ9NhTpHUJJoAGMtCJqr",[[11,"ItemSpin7",["_name"],91],[3,["_lpos"],91,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],91,[3,0,0,-0.7071067811865476,-0.7071067811865475]],[3,["_euler"],91,[1,0,0,-270]]]],107]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-472,[17,"08vKO/zSRCmIAurg4s7VOs",[[11,"ItemSpin8",["_name"],92],[3,["_lpos"],92,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],92,[3,0,0,-0.3826834323650899,-0.9238795325112867]],[3,["_euler"],92,[1,0,0,-315]]]],108]],[27,"Turns",33554432,15,[[[2,-473,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,177.67000000000002,50.4]],-474],4,1],[1,0,-35,0]],[5,"Logo",33554432,1,[[2,-475,[0,"f7NISe7HdAD68SLfhnddy8"],[5,585,197]],[24,0,-476,[0,"e71ctEmpxFC4KlSYRZNz/a"],111]],[1,0,490,0]],[145,1000,94,[0,"0b7a7v3FVOCpzmec7amMlB"],[[112,null],6,0],[15],[9,0.75],[1],[1],[9,-0.1],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,5,10],[9,0.1],[9,5],[1],[45,[15]],[147,true,0,0.01,0.20943951023931956,[9,1],[1,25,0.2,25]],[46,true,[146,1,[78,2,8,[[79,1],[64,0.69,1],[64,1,-0.01]]]],[1],[1],[1]],[47,[1],[1],[1],[9,1]],[148,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[149,0.21,[1],[1],[1],[4,3,0.5,1]],[48,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[49,true,3,3,1,true,1,[44,3,8],[1]],[50,[9,1],[1],[15],[15],-477],[51,113]],[94,"Main Camera","c9DMICJLFO5IeO07EPon7U",67,[[154,1822425087,-478,[4,4284690175]]],[1,-10,10,10],[3,-0.27781593346944056,-0.36497167621709875,-0.11507512748638377,0.8811195706053617],[1,-35,-45,0]],[144,false,2],[156,1,150],[102,"Camera",3,[-479],[1,0,0,1000]],[155,0,1073741824,750,2000,6,41943040,154,[4,4284690175]],[157,9,14],[40,2,98,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[158,4,10,157,[100,102,103]],[57,"5",50,50,1,false,73,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4278190335]],[32,3,0.9,45,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Minus",5],[8,"cc.AudioSource","play",2]],[4,4292269782],45],[32,3,0.9,46,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Add",5],[8,"cc.AudioSource","play",2]],[4,4292269782],46],[57,"5",50,50,1,false,74,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4278190335]],[32,3,0.9,26,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Exchange",5],[8,"cc.AudioSource","play",2]],[4,4292269782],26],[159,5,6,160,161,163,159,162],[57,"Error here",30,30,1,false,78,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4283914071]],[160,18,19,165],[108,1,0,109,[0,"02Vchn8fFF/77B+7pVCQuQ"],[4,4284888063]],[161,1,29,[0,"f4i77UV0dH4pcD0KQOXx7c"],167],[162,0.23,0.75,false,28,[0,"a8UaPDxYhIX5MrqvKGMJdR"],56,168],[163,20,21,56],[164,11,60],[32,3,0.9,30,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","Exit",1]],[4,4292269782],30],[32,3,0.9,31,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","History",1]],[4,4292269782],31],[77,"scrolling text scrolling text scrolling text scrolling text scrolling text scrolling text scrolling text ",0,18,18,false,true,129,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4282335039]],[77,"scrolling text scrolling text scrolling text scrolling text scrolling text scrolling text scrolling text ",0,18,18,false,true,130,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4282335039]],[165,23,62,174,175],[109,0,85,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,0]],[110,3,2,137,[0,0.5,0.5]],[166,66,178],[167,13,179,[139,141,142,143,144,145,146,147]],[168,"<color=#0b3b59>Còn lại</color><color=#ff245f> 0 </color><color=#0b3b59>lượt</color>",1,28,false,148,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[32,3,0.9,15,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","Spin",1]],[4,4292269782],15]],0,[0,0,1,0,-2,153,0,0,1,0,-1,61,0,-2,31,0,-3,23,0,-4,24,0,-5,13,0,-6,15,0,-7,149,0,-8,94,0,-1,152,0,0,3,0,21,155,0,0,3,0,0,3,0,-1,154,0,-3,9,0,-4,4,0,-5,5,0,-6,18,0,-7,20,0,-8,11,0,-9,30,0,0,4,0,0,4,0,-3,158,0,-1,37,0,-2,10,0,-3,40,0,-4,71,0,-5,41,0,0,5,0,-2,164,0,0,5,0,-1,42,0,-2,6,0,0,6,0,0,6,0,-1,72,0,-2,43,0,-3,16,0,-4,47,0,-5,26,0,-6,17,0,-7,49,0,0,7,0,0,7,0,-1,112,0,-2,113,0,-3,114,0,-4,115,0,-5,116,0,-6,117,0,-7,118,0,-8,119,0,0,8,0,-1,139,0,-2,141,0,-3,142,0,-4,143,0,-5,144,0,-6,145,0,-7,146,0,-8,147,0,0,9,0,0,9,0,-3,156,0,-1,33,0,-2,14,0,0,10,0,0,10,0,-1,69,0,-2,38,0,-3,98,0,-4,39,0,-5,25,0,0,11,0,0,11,0,0,11,0,-4,171,0,-1,60,0,-2,111,0,-4,120,0,0,12,0,0,12,0,0,12,0,-1,122,0,-2,123,0,-3,124,0,-4,126,0,0,12,0,-1,122,0,-2,123,0,-3,124,0,-4,126,0,0,13,0,-2,180,0,-1,135,0,-2,136,0,-3,85,0,-4,66,0,-5,138,0,0,14,0,0,14,0,-1,68,0,-2,34,0,-3,35,0,-4,36,0,0,15,0,0,15,0,-3,182,0,0,15,0,-1,93,0,-2,148,0,0,16,0,0,16,0,-1,44,0,-2,73,0,-3,45,0,-4,46,0,0,17,0,0,17,0,7,17,0,0,17,0,-1,76,0,-2,77,0,0,18,0,0,18,0,-3,166,0,-1,50,0,-2,19,0,0,19,0,0,19,0,-1,51,0,-2,52,0,-3,53,0,0,20,0,0,20,0,-3,170,0,-1,54,0,-2,21,0,0,21,0,0,21,0,-1,27,0,-2,58,0,-3,59,0,0,22,0,-1,81,0,-2,82,0,-3,83,0,-4,84,0,0,22,0,-1,81,0,-2,82,0,-3,83,0,-4,84,0,0,23,0,-2,176,0,0,23,0,-1,62,0,-2,129,0,-3,130,0,0,24,0,22,176,0,-1,131,0,-2,132,0,-3,133,0,-4,134,0,0,24,0,-1,131,0,-2,132,0,-3,133,0,-4,134,0,0,25,0,0,25,0,7,25,0,0,25,0,-1,70,0,0,26,0,0,26,0,-3,163,0,-1,75,0,0,27,0,0,27,0,0,27,0,-1,55,0,-2,28,0,0,28,0,-2,169,0,0,28,0,-1,29,0,-2,57,0,0,29,0,0,29,0,0,29,0,-4,168,0,-1,109,0,0,30,0,-2,172,0,0,30,0,-1,121,0,0,31,0,-2,173,0,0,31,0,-1,128,0,0,33,0,0,33,0,0,33,0,0,33,0,0,34,0,0,34,0,7,34,0,0,34,0,0,35,0,0,35,0,7,35,0,0,35,0,0,36,0,7,36,0,0,36,0,-1,97,0,0,37,0,0,37,0,0,37,0,0,37,0,0,38,0,0,38,0,0,38,0,0,38,0,0,39,0,7,39,0,0,39,0,-1,99,0,-1,100,0,0,40,0,0,40,0,0,40,0,-1,103,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,42,0,0,43,0,0,43,0,0,43,0,0,43,0,0,44,0,0,44,0,0,44,0,0,44,0,0,45,0,0,45,0,-3,160,0,0,46,0,0,46,0,-3,161,0,0,47,0,0,47,0,-1,48,0,-2,74,0,0,48,0,0,48,0,0,48,0,0,48,0,0,49,0,7,49,0,0,49,0,-1,104,0,0,50,0,0,50,0,0,50,0,0,50,0,0,51,0,0,51,0,0,51,0,-1,78,0,0,52,0,7,52,0,0,52,0,-1,105,0,0,53,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,-1,106,0,-2,79,0,0,56,0,0,56,0,0,57,0,0,57,0,0,57,0,0,58,0,7,58,0,0,58,0,-1,110,0,0,59,0,0,59,0,0,59,0,0,59,0,0,60,0,0,60,0,0,60,0,0,61,0,0,61,0,0,62,0,0,62,0,0,62,0,0,66,0,0,66,0,-3,179,0,-1,137,0,-1,151,0,-2,95,0,0,68,0,0,68,0,0,68,0,0,69,0,0,69,0,0,69,0,0,70,0,0,70,0,0,70,0,-1,102,0,0,71,0,0,71,0,0,72,0,0,72,0,0,72,0,0,73,0,-2,159,0,0,73,0,0,74,0,-2,162,0,0,74,0,0,75,0,0,75,0,0,75,0,0,76,0,0,76,0,0,76,0,0,77,0,0,77,0,0,77,0,0,78,0,-2,165,0,0,78,0,0,79,0,-1,107,0,-2,108,0,0,81,0,0,81,0,0,82,0,0,82,0,0,83,0,0,83,0,0,84,0,0,84,0,0,85,0,-2,177,0,0,85,0,0,93,0,0,93,0,0,93,0,-1,150,0,0,94,0,0,94,0,23,152,0,24,170,0,25,164,0,26,158,0,27,156,0,28,166,0,29,171,0,30,153,0,0,95,0,-1,96,0,0,96,0,0,97,0,0,97,0,0,98,0,-2,157,0,0,99,0,0,99,0,14,100,0,31,101,0,14,102,0,14,103,0,0,104,0,0,104,0,0,105,0,0,105,0,0,106,0,0,106,0,0,107,0,0,107,0,0,108,0,0,108,0,0,109,0,-2,167,0,0,110,0,0,110,0,0,111,0,0,111,0,0,112,0,0,112,0,0,113,0,0,113,0,0,114,0,0,114,0,0,115,0,0,115,0,0,116,0,0,116,0,0,117,0,0,117,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,121,0,0,121,0,4,122,0,4,123,0,8,125,0,8,125,0,8,125,0,4,124,0,8,127,0,8,127,0,8,127,0,4,126,0,0,128,0,0,128,0,0,129,0,-2,174,0,0,130,0,-2,175,0,4,131,0,4,132,0,4,133,0,4,134,0,0,135,0,0,135,0,0,136,0,0,136,0,0,137,0,-2,178,0,0,138,0,0,138,0,8,140,0,8,140,0,8,140,0,4,139,0,4,141,0,4,142,0,4,143,0,4,144,0,4,145,0,4,146,0,4,147,0,0,148,0,-2,181,0,0,149,0,0,149,0,14,150,0,0,151,0,-1,155,0,32,67,1,9,3,2,9,96,3,9,67,7,9,11,8,9,13,12,9,61,22,9,61,56,9,57,153,33,172,153,34,173,153,35,182,153,36,181,153,37,177,153,38,180,168,39,169,479],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,152,159,160,161,162,163,165,167,170,172,173,174,175,177,178,181,181,182,153,153],[1,1,1,6,1,6,1,6,10,11,12,1,1,3,1,6,10,11,12,3,1,6,-1,15,-1,15,-1,15,1,1,3,3,1,1,1,3,1,3,1,3,3,1,6,1,6,10,11,12,1,1,1,6,10,11,12,3,1,1,3,3,1,1,1,6,10,11,12,3,1,1,1,1,1,1,1,1,1,1,1,-1,40,1,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,3,1,1,-1,15,41,3,6,6,3,6,3,1,42,6,6,3,3,1,1,3,43,6,44,45],[1,32,18,18,19,19,9,3,3,10,11,1,33,4,9,3,3,10,11,2,7,7,13,8,13,8,13,8,1,16,4,4,20,21,22,4,22,2,7,2,2,7,7,9,3,3,10,11,1,16,9,3,3,10,11,4,1,1,2,2,1,16,9,3,3,10,11,4,1,34,5,5,5,5,5,5,5,5,35,23,23,36,14,14,14,14,24,25,25,24,37,38,1,15,15,15,15,39,40,41,42,6,6,6,6,6,6,6,6,4,17,43,13,8,44,4,20,21,4,7,2,1,45,1,1,2,2,1,46,2,2,17,17,47]],[[{"name":"logo_vongquaymytour","rect":{"x":901,"y":1765,"width":585,"height":197},"offset":{"x":0,"y":0},"originalSize":{"width":585,"height":197},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"app_download","rect":{"x":1137,"y":733,"width":693,"height":728},"offset":{"x":0,"y":0},"originalSize":{"width":693,"height":728},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[169,"button_tap",".mp3",1.285063]],0,0,[],[],[]],[[{"name":"gift_front","rect":{"x":901,"y":1509,"width":653,"height":250},"offset":{"x":0,"y":0},"originalSize":{"width":653,"height":250},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"popup","rect":{"x":1807,"y":1801,"width":201,"height":167},"offset":{"x":0,"y":0},"originalSize":{"width":201,"height":167},"rotated":false,"capInsets":[80,100,95,55],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[38,"ItemGift"],[66,"ItemGift",33554432,[-8,-9],[[2,-2,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,616,122]],[170,-7,[0,"15V6KItCJGAIu1qnMu7KxT"],-6,-5,-4,-3]],[18,"80oVypFg9Ea5rK9ZuAfYlh",-1,0],[1,0,-141,0]],[95,"Container",33554432,1,[-11,-12,-13],[[2,-10,[0,"3242DVCWtMepBNxixN/wo6"],[5,616,122]]],[18,"2cAB3vm0dMyI7ZFgt7HE8v",1,0]],[71,"Bg",33554432,1,[[[2,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,616,122]],-15],4,1],[18,"a8OMyFqFRGBqO1fu7Q0rmJ",1,0]],[53,"Icon",33554432,2,[[[2,-16,[0,"f7NISe7HdAD68SLfhnddy8"],[5,185,179]],-17],4,1],[18,"74ncfWgRxBVqtM2PvgcJT2",1,0],[1,-225,0,0]],[53,"Description",33554432,2,[[[13,-18,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,94],[0,0,0.5]],-19],4,1],[18,"8aK+R4pM9M2YIhahqJqu60",1,0],[1,-140,0,0]],[53,"Time",33554432,2,[[[13,-20,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,94],[0,0,0.5]],-21],4,1],[18,"138ACOBEhDCJHTetcW3C00",1,0],[1,200,0,0]],[40,0,3,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[40,2,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[133,"Gift",0,25,25,30,1,false,false,5,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488]],[134,"02/07\n16:59",0,25,25,30,1,false,6,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488]]],0,[0,4,1,0,0,1,0,46,10,0,47,9,0,16,8,0,17,7,0,0,1,0,-1,3,0,-2,2,0,0,2,0,-1,4,0,-2,5,0,-3,6,0,0,3,0,-2,7,0,0,4,0,-2,8,0,0,5,0,-2,9,0,0,6,0,-2,10,0,13,1,21],[7,9,10],[1,3,3],[1,2,2]],[[{"name":"btt_spin_b","rect":{"x":1807,"y":368,"width":359,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":359,"height":182},"rotated":true,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_lightoff","rect":{"x":3,"y":719,"width":670,"height":670},"offset":{"x":0,"y":0},"originalSize":{"width":670,"height":670},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[[171,"builtin-particle",[{"hash":1755172438,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3314483928,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3916783067,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":1118626722,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[{"name":"btt_minus","rect":{"x":1744,"y":1467,"width":54,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":58},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_back","rect":{"x":1995,"y":3,"width":48,"height":73},"offset":{"x":0,"y":0},"originalSize":{"width":48,"height":73},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[38,"ItemNotification"],[96,"ItemNotification",33554432,[-6],[[13,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,550,50],[0,0.5,0]],[30,1,0,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[172,-5,[0,"88W+AM2qdM7YL43Rm/wu6E"],-4]],[18,"7aFiDHn+NClKHPLQ2dj3zj",-1,0]],[71,"Label",33554432,1,[[[13,-7,[0,"c68UOAlNhN171Umca6yVvF"],[5,550,50],[0,0.5,0]],-8,[119,45,42.22,50.4,1,-9,[0,"cduD0aCNtBFK4RCCgUXAF2"]]],4,1,4],[18,"84yO6BiwFDMrUdCMsCSdJv",1,0]],[135,18,18,1,false,false,2,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281479730]]],0,[0,4,1,0,0,1,0,0,1,0,48,3,0,0,1,0,-1,2,0,0,2,0,-2,3,0,0,2,0,13,1,9],[0,3],[1,3],[48,2]],[[{"name":"white","rect":{"x":1413,"y":1968,"width":64,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":64,"height":64},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_loading_mytour","rect":{"x":1165,"y":1968,"width":242,"height":57},"offset":{"x":0,"y":0},"originalSize":{"width":242,"height":57},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"gift_behide","rect":{"x":3,"y":1509,"width":892,"height":486},"offset":{"x":0,"y":0},"originalSize":{"width":892,"height":486},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_history","rect":{"x":1560,"y":1612,"width":122,"height":141},"offset":{"x":0,"y":0},"originalSize":{"width":122,"height":141},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_bluelight","rect":{"x":1492,"y":1765,"width":269,"height":309},"offset":{"x":21,"y":-3.5},"originalSize":{"width":311,"height":356},"rotated":true,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_glowlight","rect":{"x":649,"y":1395,"width":311,"height":356},"offset":{"x":0,"y":0},"originalSize":{"width":311,"height":356},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"name":"deco_voucher_2","rect":{"x":1836,"y":997,"width":124,"height":121},"offset":{"x":0,"y":0},"originalSize":{"width":124,"height":121},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[173,[[174,"ShadowFlow",[[175,"ShadowStage"]]],[176,"ForwardFlow",1,[[177,"ForwardStage",[[178,["default"]],[179,true,1,["default"]]]]]]]]],0,0,[],[],[]],[[{"name":"icon_loading_dotc","rect":{"x":1744,"y":1531,"width":55,"height":55},"offset":{"x":0,"y":0},"originalSize":{"width":55,"height":55},"rotated":false,"capInsets":[0,0,0,0],"texture":"1e69327bf@6c48a","packable":true}],[0],0,[0],[2],[0]]]]
