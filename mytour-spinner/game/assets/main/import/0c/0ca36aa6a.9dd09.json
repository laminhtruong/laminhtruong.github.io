[1,["1444b2a78@6c48a","e2uRISfu5MxLMoT+f2TEdu@f9941","51V+p7Zt1NDbMzgUVpCq0x","20g1ukYUVPvKWKBRznAKo+@f9941","88A6d07iNLSaRkaORvPaEN","69THl8CTRHe42k/C5WgHvu@f9941","7fFz8RNk5CgYDm7hmnra4/","15DyFwMQ1BgKNwJkeUufkb@f9941","836yr8qLBBH6v4l45wp2l2@6c48a","7ewTkjDxlIYYeENMA3mC8w@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","17699fa08@6c48a","969WVMeoRIt7JvKrq5OMI+","8ahMOAAftDboobZSHonVAy","e00c0trElNk4ufxzKBASLR","c3qMYD/7FOR4tU/q0feraG@f9941","22TbdrVWhCQr9E4IR1zjWB@f9941","3d53wxdQlLsoC/5P0yZ4EO@f9941","4bEmi6rDpGOotcKEFgTgh6@f9941","d7iAycONZLjbS7fvx8FdiV@f9941","3e+vAy1ttBIb5aOViD2mQQ@f9941","03qLmiB2FKNIQ/Oai3ne0+@f9941","78q26pg5hG85/QLom1Nrjp","43cxfhTEpDJJR4Qnka9AXX@f9941","fdSEV6iLpN8YQP4pqqdYeH@f9941","20g1ukYUVPvKWKBRznAKo+@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","f56i//Q3NBSKDKqlZvaT6X@f9941","f9d/1Y9BRMZpOmhT8k47aI@f9941","95EkngnxZFbYuFpsqVTaFr@6c48a","d1NGQ2rJZCcbhjH0/erZWw","c6H2Ccy51O54Wcjy/B/JbV","a6RC7arGZOL4FuNB81yd04@f9941","21NqNxLBtJnZtpFPUfYPOZ@f9941","e8h+9K415L95FgUaVj8zBo@f9941","68buC/x6tMMqTchRm2Njvq@f9941","dcZUS9UklAh7kyBcFVt4EF@f9941","7bezKBZrJIHKAUgWC8Tw71@f9941","f2dna4OWpB0IMyk21r1ZDW@f9941","f1lA2++0VG1Zbb4N7b15sN@f9941","94PiB+3HZGyZxCnSimlYbV@f9941","d0jUsIZcVG3aQg58p2Im4i@f9941","bd2Azsv11Bx7cg+3Xqj0yM@f9941","a4vzUWXWhHMpeh9To8BQo2@f9941","b4TqwhPJpOv5osY+eFmNjc","c4WU7Oc5ZE37KJhjLUU5Ik","85DE6oKK1IG791cMZWQO5D@f9941","cbfYen60hGtLGwV4CgKzDB@f9941","6bZ2RlGdtCUbO0qSzblPgm@f9941"],["node","_spriteFrame","_textureSource","_font","root","asset","_normalSprite","_target","targetInfo","_parent","_hoverSprite","_pressedSprite","_disabledSprite","data","_particleSystem","_mainTexture","icon","bg","_clip","light","mainTexture","_effectAsset","_cameraComponent","audioTap","popupHistory","popupExchangeTurn","popupGift","popupWarning","popupError","loading","scrollingText","main","curve","scene","buttonBack","buttonHistory","buttonSpin","turns","overlay","spinner","_scrollView","_defaultClip","prefabItem","_userDefinedFont","spirteSpinNormal","spirteSpinDisable","time","description","information"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_id","_active","_components","_parent","_children","_lpos","_prefab","_lscale","_lrot","_euler"],-1,9,1,2,5,4,5,5,5],["cc.Sprite",["_sizeMode","_type","_fillType","_fillStart","_fillRange","node","__prefab","_spriteFrame","_color","_fillCenter"],-2,1,4,6,5,5],["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_top","_left","_right","_bottom","_alignMode","node","__prefab"],-5,1,4],["cc.Node",["_name","_layer","_active","_components","_parent","_lpos","_children","_prefab","_lscale","_lrot","_euler"],0,12,1,5,2,4,5,5,5],["cc.Label",["_actualFontSize","_isSystemFontUsed","_string","_overflow","_fontSize","_isBold","_horizontalAlign","_enableWrapText","_lineHeight","node","__prefab","_color","_font"],-6,1,4,5,6],"cc.ImageAsset","cc.Texture2D",["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.CurveRange",["mode","constantMax","constant","constantMin","curve"],-1,1],["cc.Button",["_transition","_zoomScale","node","__prefab","clickEvents","_normalColor","_target","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],1,1,4,9,5,1,6,6,6,6],["cc.Keyframe",["value","time"],1],["cc.Node",["_name","_components","_parent","_lpos"],2,2,1,5],["cc.PrefabInfo",["fileId","targetOverrides","root","asset"],1,1,1],["cc.Layout",["_layoutType","_spacingX","_resizeMode","node"],0,1],["cc.Mask",["node","__prefab"],3,1,4],["cc.AudioSource",["_loop","_playOnAwake","node","_clip"],1,1,6],["cc.ParticleSystem",["loop","playOnAwake","_capacity","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","bursts"],0,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9],["cc.ShapeModule",["_enable","radius","_angle","emitFrom","_shapeType","arcSpeed","_rotation","_scale"],-2,4,5,5],["cc.ForceOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.LimitVelocityOvertimeModule",["dampen","_enable","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents"],1,9,9],["cc.Camera",["_visibility","_projection","_priority","_orthoHeight","_far","_clearFlags","node","_color"],-3,1,5],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],["cc.TTFFont",["_name","_native"],1],["cc.AnimationClip",["_name","speed","wrapMode","_duration","_hash","_curves","_keys","_commonTargets"],-4,12],["cc.animation.HierarchyPath",["path"],2],["cc.Prefab",["_name"],2],["cc.CompPrefabInfo",["fileId"],2],["80778T/Aw5KTqtRMvdABmlf",["node","__prefab","bg","icon","light"],3,1,4,1,1,1],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.Material",["_techIdx","_states","_defines","_props"],0,12],["cc.SceneAsset",["_name"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.BlockInputEvents",["node"],3,1],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["180c9lqTTZHVpxGKnnQEokO",["node","lights"],3,1,2],["cc.ClickEvent",["_componentId","handler","target"],1,1],["59a412K1NxEW77Yknuvdy8e",["node","items"],3,1,2],["e6329fh7QdHiYn7arpg1TCs",["node","Notifications"],3,1,2],["cc.TargetInfo",["localID"],2],["cc.LabelOutline",["node","_color"],3,1,5],["cc.LabelShadow",["node","_color","_offset"],3,1,5,5],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",[],3],["2df67cPW6dPX48dJVTWAnOy",["node","main","scrollingText","loading","popupError","popupWarning","popupGift","popupExchangeTurn","popupHistory","audioTap"],3,1,1,1,1,1,1,1,1,1,1],["cc.GradientRange",[],3],["cc.CurveRange",["mode","curve"],2,4],["cc.Burst",["repeatInterval","count"],2,4],["cc.ColorOvertimeModule",["color"],3,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","cycleCount","randomRow","rowIndex","frameOverTime","startFrame"],-3,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.AnimationCurve",["preWrapMode","postWrapMode","keyFrames"],1,9],["cc.MountedComponentsInfo",["components","targetInfo"],2,4],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["418ddTz9+lC7bF5livsSJvo",["node","confettiDrop"],3,1,1],["9c69ay9pCVG/5YDrJ1oySld",["node","container"],3,1,1],["ae5e6oHii1DAp8iAq9daOTv",["node","container","gift","particleWin"],3,1,1,1,2],["b495dvYo/BJlKfocklL9tQG",["node","container","buttonMinus","buttonAdd","buttonExchange","labelTurn","labelCoin"],3,1,1,1,1,1,1,1],["cd786OL4KtC4rtPw+E8R6+f",["node","container","message"],3,1,1,1],["cc.ScrollBar",["_direction","node","__prefab","_handle"],2,1,4,1],["cc.ScrollView",["bounceDuration","brake","horizontal","node","__prefab","_content","_verticalScrollBar"],0,1,4,1,1],["bdf99lAQSJLuJR79SBJsE50",["node","container","content"],3,1,1,1],["f2b2fXBSjhBZ4KwKnXZ/HX5",["node","overlay"],3,1,1],["bf50fwUJItJvYyJzbCOdU+b",["node","text1","text2"],3,1,1,1],["729d4KJjzhGfL0qDutk2ZsF",["node","light"],3,1,1],["c86cddfDZxLm7NGiOKG8yCW",["node","light","items"],3,1,1,2],["cc.RichText",["_string","_horizontalAlign","_fontSize","_isSystemFontUsed","node","__prefab"],-1,1,4],["cc.AudioClip",["_name","_native","_duration"],0],["2ae10c7koBII5m9zSeuZOfS",["node","__prefab","bg","icon","description","time"],3,1,4,1,1,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["45db9SjQ7xMLrjPwl8puXSz",["node","__prefab","information"],3,1,4,1],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[28,0,2],[9,1],[8,0,2,1,1],[66,0,1,2,2],[9,0,3,1,4],[1,0,1,5,4,7,3],[40,0,2],[8,0,1,1],[37,0,1,2,3],[9,2,2],[3,0,1,2,8,4],[65,0,1,2,3],[1,5,8,1],[8,0,2,1,3,1],[30,0,1,2,3,2],[51,1],[21,0,2,2],[1,0,1,5,4,3],[13,0,2,3,2],[64,0,1,2,2],[2,5,7,1],[1,0,1,5,6,4,3],[1,0,1,5,6,4,7,3],[2,1,0,5,7,3],[2,0,5,6,7,2],[4,0,1,4,6,3,5,3],[2,0,5,6,8,7,2],[34,0,1],[5,2,0,4,3,1,5,9,10,12,7],[2,1,0,5,6,7,3],[3,0,4,5,3,6,1,2,8,8],[10,0,1,2,3,4,5,6,3],[41,0,1,1],[42,0,1,2,1],[4,0,2,4,6,3,3],[4,0,1,4,3,5,3],[4,0,1,4,3,3],[2,5,6,7,1],[10,0,1,2,3,4,5,6,7,8,9,10,3],[27,0,2],[4,0,1,4,3,5,8,3],[2,0,5,6,2],[2,5,6,8,7,1],[10,0,1,2,3,4,5,6,7,3],[43,0,1,1],[9,0,1,3],[54,0,1],[55,0,1,2,3,4,2],[56,0,1,2,3,1],[57,0,1,2,3,2],[58,0,1,2,3,4,5,6,7,7],[59,0,1,2,3,4,1],[60,0,1],[4,0,1,4,3,7,5,3],[8,0,1],[3,0,6,1,2,8,5],[5,2,0,4,3,1,9,10,11,6],[17,0,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,29,19,20,21,22,23,24,25,26,27,28,3],[9,0,4,2],[53,0,1,2],[18,0,3,1,2,5,6,5],[19,0,1,2,3,2],[20,1,0,2,3,4,5,3],[11,1,0,3],[24,0,1,3],[1,0,1,6,4,8,7,3],[1,0,1,6,4,3],[1,0,1,5,4,9,3],[1,0,1,5,4,7,10,9,11,3],[4,0,1,4,3,7,3],[8,0,1,3,1],[3,0,1,8,3],[3,0,3,8,3],[3,0,5,8,3],[3,0,3,6,1,2,8,6],[5,2,6,0,3,1,5,9,10,12,7],[5,2,6,0,4,1,5,9,10,11,7],[61,0,1,2,3],[11,0,2],[80,0,1,2,4],[25,0,1,2,3,4,5,6,7,8],[26,0,2],[1,0,1,5,4,8,3],[1,0,1,5,4,8,7,3],[1,0,1,4,8,3],[1,0,1,2,6,4,7,4],[1,0,6,4,2],[1,0,1,6,4,7,3],[1,0,5,6,4,7,2],[1,0,1,4,7,3],[1,0,3,1,5,4,4],[1,0,1,5,4,7,9,3],[1,0,2,5,6,4,3],[1,0,5,6,4,2],[1,0,2,5,4,7,10,11,3],[1,0,1,5,6,4,8,3],[1,0,1,6,4,8,3],[4,0,1,4,3,7,5,9,10,3],[4,0,6,3,2],[4,0,2,1,4,6,3,4],[4,0,1,4,6,3,3],[4,0,2,1,4,3,4],[4,0,1,4,3,8,3],[12,0,1,2],[12,0,2,1,3,2],[29,0,1,2,3,4,1],[13,1,2],[2,1,2,0,3,4,5,6,8,9,7,6],[2,2,0,5,6,9,7,3],[2,1,0,5,6,8,7,3],[2,1,0,5,6,8,3],[2,0,5,6,8,2],[2,1,2,5,9,3],[31,0,1,2,3,4],[32,0,2],[3,0,8,9,2],[3,0,2,7,8,9,4],[3,0,4,5,3,1,8,6],[3,0,4,8,3],[3,0,4,5,1,2,7,8,7],[3,0,4,5,3,6,1,2,7,8,9],[3,0,1,2,7,8,9,5],[33,0,1,2,1],[14,0,1,3,3],[14,2,0,3,3],[35,0,1,2,3,2],[15,0,1],[15,0,1,1],[36,0,1,1],[38,0,1,1],[39,0,1,1],[5,2,0,3,1,5,9,10,12,6],[5,2,0,4,3,7,1,5,9,10,12,8],[5,2,6,0,4,8,3,7,1,5,9,10,11,12,10],[5,2,6,0,4,8,3,1,5,9,10,11,12,9],[5,2,6,0,4,8,3,7,1,9,10,11,9],[5,2,6,0,4,8,3,1,9,10,11,8],[5,0,4,3,7,1,9,10,11,6],[44,0,1,2,3,2],[45,0,1,2,3,1],[46,1],[47,0,1],[48,1],[49,1],[50,0,1,2,3,4,5,6,7,8,9,1],[16,0,2,3,2],[16,1,2,2],[17,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2],[52,0,1,2],[18,0,4,1,2,5,7,5],[19,1,2,3,1],[20,0,2,3,4,5,2],[11,1,2],[21,0,1,3,2,3],[62,0,1,2],[63,0,1,2,3],[22,0,6,7,2],[22,1,2,3,4,5,0,6,7,7],[67,0,1,1],[68,0,1,1],[69,0,1,2,3,1],[70,0,1,2,3,4,5,6,1],[71,0,1,2,1],[72,0,1,2,3,2],[73,0,1,2,3,4,5,6,4],[74,0,1,2,1],[75,0,1,1],[76,0,1,2,1],[77,0,1,1],[78,0,1,2,1],[79,0,1,2,3,4,5,5],[81,0,1,2,3,4,5,1],[82,0,1,2,4],[83,0,1,2,1],[84,0,1],[85,0,1,2],[86,0,2],[87,0,1,2,3],[88,0,1,2],[23,0,2],[23,1,2,0,4]],[[[{"name":"popup_textbox","rect":{"x":1807,"y":1974,"width":60,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":60,"height":66},"rotated":false,"capInsets":[20,20,20,20],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"fmt":"0","w":2046,"h":2048}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["1444b2a78"]}],[7],0,[],[],[]],[[{"name":"button_pink_glow","rect":{"x":1807,"y":1467,"width":328,"height":109},"offset":{"x":0,"y":0},"originalSize":{"width":328,"height":109},"rotated":true,"capInsets":[50,45,50,45],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"fmt":"0","w":963,"h":2038}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["17699fa08"]}],[7],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["20g1ukYUVPvKWKBRznAKo+"]}],[7],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"20835ba4-6145-4fbc-a58a-051ce700aa3e@6c48a","packable":true}],[0],0,[0],[2],[26]],[[{"name":"popup_gift","rect":{"x":1137,"y":3,"width":693,"height":636},"offset":{"x":0,"y":0},"originalSize":{"width":693,"height":636},"rotated":true,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_spin_a","rect":{"x":1807,"y":3,"width":359,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":359,"height":182},"rotated":true,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_download_apple","rect":{"x":1922,"y":733,"width":258,"height":86},"offset":{"x":0,"y":0},"originalSize":{"width":258,"height":86},"rotated":true,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_add","rect":{"x":1940,"y":1974,"width":54,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":58},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"deco_voucher_1","rect":{"x":1560,"y":1467,"width":178,"height":139},"offset":{"x":0,"y":0},"originalSize":{"width":178,"height":139},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_download_google","rect":{"x":901,"y":1968,"width":258,"height":77},"offset":{"x":0,"y":0},"originalSize":{"width":258,"height":77},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[64,"utm-avo","utm-avo.ttf"]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["54TknWPwVPqJqeCR+Y/Czo"]}],[7],0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@6c48a","packable":true}],[0],0,[0],[2],[27]],[[{"name":"icon_loading_dotb","rect":{"x":109,"y":2001,"width":17,"height":21},"offset":{"x":0,"y":0},"originalSize":{"width":17,"height":21},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_loading_dota","rect":{"x":109,"y":2028,"width":13,"height":17},"offset":{"x":0,"y":0},"originalSize":{"width":17,"height":21},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"notification_bg","rect":{"x":3,"y":2001,"width":100,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":100,"height":36},"rotated":false,"capInsets":[30,0,30,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[80,"loading",2,54,1.3333333333333333,1850637711,[{"commonTarget":0,"modifiers":["x"],"data":{"keys":0,"values":[-63.5,-45.5,-27.5,-9.5,8.5,26.5,44.5,62.5,-63.5],"easingMethods":{"0":"constant","1":"constant","2":"constant","3":"constant","4":"constant","5":"constant","6":"constant","7":"constant","8":"constant"}}},{"commonTarget":0,"modifiers":["y"],"data":{"keys":1,"values":[0,0,0,0,0,0,0,0,0],"easingMethods":{"0":"constant","1":"constant","2":"constant","3":"constant","4":"constant","5":"constant","7":"constant","8":"constant"}}},{"commonTarget":0,"modifiers":["z"],"data":{"keys":2,"values":[0,0,0,0,0,0,0,0,0],"easingMethods":{"0":"constant","1":"constant","2":"constant","3":"constant","4":"constant","5":"constant","7":"constant","8":"constant"}}}],[[0,0.16666666666666666,0.3333333333333333,0.5,0.6666666666666666,0.8333333333333334,1,1.1666666666666667,1.3333333333333333],[0,0.16666666666666666,0.3333333333333333,0.5,0.6666666666666666,0.8333333333333334,1,1.1666666666666667,1.3333333333333333],[0,0.16666666666666666,0.3333333333333333,0.5,0.6666666666666666,0.8333333333333334,1,1.1666666666666667,1.3333333333333333]],[[[{},"modifiers",12,[[[81,"DogBig"],"position"],4,0]]],11]]],0,0,[],[],[]],[[{"name":"bg","rect":{"x":3,"y":3,"width":1128,"height":1500},"offset":{"x":0,"y":0},"originalSize":{"width":1128,"height":1500},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"popup_close","rect":{"x":1873,"y":1974,"width":61,"height":61},"offset":{"x":0,"y":0},"originalSize":{"width":61,"height":61},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[39,"ItemSpin"],[65,"ItemSpin",33554432,[-7,-8,-9],[[13,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,269,309],[0,0.089,0.08]],[105,-6,[0,"270UhrKwJN4Yj+pLBLmdV7"],-5,-4,-3]],[18,"3empOM9gJKLaiwBBtK/4Le",-1,0],[1,-0.3140000000000214,48.29399999999998,0]],[82,"Bg",33554432,1,[[13,-10,[0,"f7NISe7HdAD68SLfhnddy8"],[5,269,309],[0,0.089,0.08]],[37,-11,[0,"e71ctEmpxFC4KlSYRZNz/a"],0]],[18,"d5xvKmkx5H6ZYUU2PHgO4p",1,0]],[83,"Light",33554432,1,[[2,-12,[0,"f7NISe7HdAD68SLfhnddy8"],[5,311,356]],[37,-13,[0,"e71ctEmpxFC4KlSYRZNz/a"],1]],[18,"c31js76TJAZbcrJTiPU30m",1,0],[1,90.5,136.962,0]],[97,"Icon",33554432,1,[[[2,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,200,200]],-15],4,1],[18,"4e8fX8HyVOrpgIKHxs5Kac",1,0],[1,75,184,0],[3,0,0,-0.19509032201612825,0.9807852804032304],[1,0,0,-22.5]],[41,2,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]]],0,[0,4,1,0,0,1,0,19,3,0,16,5,0,17,2,0,0,1,0,-1,2,0,-2,4,0,-3,3,0,0,2,0,0,2,0,0,3,0,0,3,0,0,4,0,-2,5,0,13,1,15],[0,0],[1,1],[28,29]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["836yr8qLBBH6v4l45wp2l2"]}],[7],0,[],[],[]],[[{"name":"luckywheel_lighton","rect":{"x":3,"y":3,"width":710,"height":710},"offset":{"x":0,"y":0},"originalSize":{"width":710,"height":710},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[[64,"iCielPanton-Black","iCielPanton-Black.ttf"]],0,0,[],[],[]],[[[39,"Light"],[84,"Light",33554432,[[13,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,150,2000],[0,0.5,0]],[107,3,2,0,0.244,0.015,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4293983231],[0,0.5,0],0]],[18,"b2fdGMTRlIcIXQiFGMJj1n",-1,0]]],0,[0,4,1,0,0,1,0,0,1,0,13,1,3],[0],[1],[1]],[[{"name":"luckywheel_base","rect":{"x":3,"y":1395,"width":640,"height":640},"offset":{"x":0,"y":0},"originalSize":{"width":640,"height":640},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["95EkngnxZFbYuFpsqVTaFr"]}],[7],0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"951249e0-9f16-456d-8b85-a6ca954da16b@6c48a","packable":true}],[0],0,[0],[2],[30]],[[[113,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[20,21],[8,31]],[[[114,"main"],[98,"Main",[-4,-5,-6,-7,-8,-9,-10,-11],[[[7,-1,[5,750,1500]],-2,[10,45,100,100,-3]],4,1,4]],[103,"Tap",[-12]],[85,"Canvas",33554432,"0dDmbhkC9Ftb0hdJwrl+Yu",[-17,1,-18,-19,-20,-21,-22,-23,-24],[[2,-13,[0,"0dngp/9gNO34wUQjZfN/CX"],[5,750,1500]],[122,-15,[0,"3f2oTdCepERZdpmIfLsrhd"],-14],[115,45,-16,[0,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,375,750,0]],[34,"PopupGift",false,3,[-28,-29,-30,-31,-32],[[[7,-25,[5,750,1500]],[10,45,100,100,-26],-27],4,4,1]],[34,"PopupExchangeTurn",false,3,[-36,-37],[[[7,-33,[5,750,1500]],-34,[10,45,100,100,-35]],4,1,4]],[21,"Container",33554432,5,[-40,-41,-42,-43,-44,-45,-46],[[7,-38,[5,750,1500]],[10,45,100,100,-39]]],[66,"Dots",33554432,[-49,-50,-51,-52,-53,-54,-55,-56],[[7,-47,[5,140,50]],[123,1,5,-48]]],[86,"Items",[-58,-59,-60,-61,-62,-63,-64,-65],[[54,-57]]],[34,"PopupWarning",false,3,[-69,-70],[[[7,-66,[5,750,1500]],[10,45,100,100,-67],-68],4,4,1]],[21,"Container",33554432,4,[-73,-74,-75,-76,-77],[[7,-71,[5,750,1500]],[10,45,100,100,-72]]],[99,"Loading",false,33554432,3,[-82,-83,7,-84],[[[7,-78,[5,750,1500]],[27,-79],[125,true,-80,[80],81],-81],4,4,4,1]],[87,"Light",33554432,[-93,-94,-95,-96],[[70,-85,[5,1128,880],[0,0.5,1]],[126,-86],[71,41,100,-87],[128,-92,[-88,-89,-90,-91]]],[1,0,750,0]],[100,"Spinner",33554432,1,[-99,-100,-101,-102,-103,8],[[[54,-97],-98],4,1]],[21,"Container",33554432,9,[-106,-107,-108,-109],[[7,-104,[5,750,1500]],[10,45,100,100,-105]]],[25,"ButtonSpin",33554432,1,[-114,-115],[[[2,-110,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,359,182]],[108,2,0,-111,[0,"77BcV1zfNHo4LI4KRqZupe"],[0,0.5,0.5],111],-112,[72,1,1084,-113]],4,4,1,4],[1,0,-425,0]],[22,"Turns",33554432,6,[-118,-119,-120,-121],[[7,-116,[5,320,66]],[23,1,0,-117,35]],[1,100,100,0]],[22,"ButtonShare",33554432,6,[-126,-127],[[2,-122,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[23,1,0,-123,42],[43,3,0.9,-125,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Share",5],[8,"cc.AudioSource","play",2]],[4,4292269782],-124,43]],[1,0,-190,0]],[34,"PopupError",false,3,[-131,-132],[[[7,-128,[5,750,1500]],[10,45,100,100,-129],-130],4,4,1]],[21,"Container",33554432,18,[-135,-136,-137],[[7,-133,[5,750,1500]],[10,45,100,100,-134]]],[34,"PopupHistory",false,3,[-141,-142],[[[7,-138,[5,750,1500]],[10,45,100,100,-139],-140],4,4,1]],[21,"Container",33554432,20,[-145,-146,-147],[[7,-143,[5,750,1500]],[10,45,100,100,-144]]],[66,"Floating",33554432,[-154,-155,-156,-157],[[54,-148],[129,-153,[-149,-150,-151,-152]]]],[25,"NotificationWinner",33554432,1,[-162,-163],[[[2,-158,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,50]],[26,0,-159,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,2164055946],92],[71,40,64,-160],-161],4,4,4,1],[1,0,625,0]],[88,"Notification",1,[-170,-171,-172,-173],[[70,-164,[5,650,135],[0,0.5,0]],[130,-169,[-165,-166,-167,-168]]],[1,0,-750,0]],[22,"ButtonShare",33554432,10,[-178],[[2,-174,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[23,1,0,-175,21],[43,3,0.9,-177,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"ae5e6oHii1DAp8iAq9daOTv","Share",4],[8,"cc.AudioSource","play",2]],[4,4292269782],-176,22]],[1,0,-210,0]],[25,"ButtonExchange",33554432,6,[-182],[[[2,-179,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,110]],[23,1,0,-180,39],-181],4,4,1],[1,0,-100,0]],[21,"Border",33554432,21,[-186,-187],[[2,-183,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,740]],[29,1,0,-184,[0,"e71ctEmpxFC4KlSYRZNz/a"],62],[30,18,63,63,370,370,624,760,-185]]],[25,"ScrollView",33554432,27,[-191,-192],[[[13,-188,[0,"71kmounFRG/K27WWBbH2RB"],[5,616,500],[0,0.5,1]],-189,[30,45,4,4,190,50,240,250,-190]],4,1,4],[1,0,180,0]],[25,"scrollBar",33554432,28,[-197],[[[13,-193,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,5,500],[0,1,0.5]],[109,1,0,-194,[0,"9dLJe/n0BKVoGauB1wT/Tc"],[4,4292861919],61],[116,37,250,1,-195,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-196],4,4,4,1],[1,308,-250,0]],[25,"ButtonBack",33554432,3,[-201],[[[2,-198,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],-199,[117,9,-35,25,50,100,-200]],4,1,4],[1,-335,625,0]],[25,"ButtonHistory",33554432,1,[-205],[[[2,-202,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,122,141]],-203,[73,32,10,-204]],4,1,4],[1,304,375,0]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[17,"Overlay",33554432,9,[[2,-206,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-207,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],1],[27,-208],[10,45,20,20,-209]]],[5,"ButtonDownloadApple",33554432,14,[[2,-210,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,258,86]],[23,1,0,-211,3],[43,3,0.9,-213,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","DownloadApple",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-212,4]],[1,0,-180,0]],[5,"ButtonDownloadGoogle",33554432,14,[[2,-214,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,258,86]],[23,1,0,-215,5],[43,3,0.9,-217,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","DownloadGoogle",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-216,6]],[1,0,-280,0]],[22,"ButtonClose",33554432,14,[-221],[[2,-218,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[38,3,0.9,-220,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"9c69ay9pCVG/5YDrJ1oySld","Close",9],[8,"cc.AudioSource","play",2]],[4,4292269782],-219,8,9,10,11]],[1,0,-460,0]],[17,"Overlay",33554432,4,[[2,-222,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-223,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],12],[27,-224],[10,45,20,20,-225]]],[5,"Title",33554432,10,[[2,-226,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,90]],[131,"KẾT QUẢ VÒNG QUAY",40,1,false,true,-227,[0,"2frm37uaJHQr0AEEaYyM82"],14],[32,-228,[4,4289425681]],[33,-229,[4,4283776010],[0,0,-2]]],[1,0,210,0]],[22,"ButtonClose",33554432,10,[-233],[[2,-230,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[38,3,0.9,-232,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"ae5e6oHii1DAp8iAq9daOTv","Close",4],[8,"cc.AudioSource","play",2]],[4,4292269782],-231,16,17,18,19]],[1,0,-360,0]],[40,"ParticleLeft",33554432,4,[[-234,[2,-235,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-236,[0,"50bRhRSqFKc4o+eXu3VyY/"]],[118,8,-20,-237]],1,4,4,4],[1,-370,-780,0],[1,50,50,50]],[40,"ParticleRight",33554432,4,[[-238,[2,-239,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-240,[0,"50bRhRSqFKc4o+eXu3VyY/"]],[73,32,-20,-241]],1,4,4,4],[1,370,-780,0],[1,50,50,50]],[17,"Overlay",33554432,5,[[2,-242,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-243,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],29],[27,-244],[10,45,20,20,-245]]],[5,"Title",33554432,6,[[2,-246,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[28,"THÊM LƯỢT",50,50,1,false,true,-247,[0,"2frm37uaJHQr0AEEaYyM82"],31],[32,-248,[4,4289425681]],[33,-249,[4,4283776010],[0,0,-2]]],[1,0,230,0]],[5,"Label",33554432,16,[[2,-250,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,90]],[75,"ĐỔI LƯỢT",0,40,1,false,true,-251,[0,"2frm37uaJHQr0AEEaYyM82"],32],[32,-252,[4,4289425681]],[33,-253,[4,4283776010],[0,0,-2]]],[1,-230,0,0]],[35,"ButtonMinus",33554432,16,[[[2,-254,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,54,58]],[23,1,0,-255,33],-256],4,4,1],[1,-125,0,0]],[35,"ButtonAdd",33554432,16,[[[2,-257,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,54,58]],[23,1,0,-258,34],-259],4,4,1],[1,125,0,0]],[22,"Rate",33554432,6,[-262,-263],[[7,-260,[5,320,66]],[23,1,0,-261,37]],[1,100,10,0]],[5,"Label",33554432,47,[[2,-264,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,90]],[75,"CÒN LẠI",0,40,1,false,true,-265,[0,"2frm37uaJHQr0AEEaYyM82"],36],[32,-266,[4,4289425681]],[33,-267,[4,4283776010],[0,0,-2]]],[1,-230,0,0]],[22,"ButtonClose",33554432,6,[-271],[[2,-268,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[38,3,0.9,-270,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Hide",5],[8,"cc.AudioSource","play",2]],[4,4292269782],-269,45,46,47,48]],[1,0,-350,0]],[17,"Overlay",33554432,18,[[2,-272,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-273,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],49],[27,-274],[10,45,20,20,-275]]],[21,"Border",33554432,19,[-279],[[2,-276,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,450]],[29,1,0,-277,[0,"e71ctEmpxFC4KlSYRZNz/a"],50],[30,18,275,275,572,572,200,190,-278]]],[22,"ButtonClose",33554432,19,[-283],[[2,-280,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[38,3,0.9,-282,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"cd786OL4KtC4rtPw+E8R6+f","Close",18],[8,"cc.AudioSource","play",2]],[4,4292269782],-281,52,53,54,55]],[1,0,-300,0]],[5,"Title",33554432,19,[[2,-284,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[28,"THÔNG BÁO",50,50,1,false,true,-285,[0,"2frm37uaJHQr0AEEaYyM82"],56],[32,-286,[4,4289425681]],[33,-287,[4,4283776010],[0,0,-2]]],[1,0,180,0]],[17,"Overlay",33554432,20,[[2,-288,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-289,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],57],[27,-290],[10,45,20,20,-291]]],[22,"Title",33554432,27,[-294,-295],[[2,-292,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,616,94]],[72,1,93,-293]],[1,0,230,0]],[89,"content",33554432,[[13,-296,[0,"99yn0cfL9MmZYfJbPmK9qL"],[5,610,610],[0,0.5,1]],[124,1,2,-297]],[1,-5,0,0]],[21,"view",33554432,28,[56],[[13,-298,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,608,500],[0,0.5,1]],[127,-299,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[119,45,4,4,240,250,1,-300]]],[22,"ButtonClose",33554432,21,[-304],[[2,-301,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[38,3,0.9,-303,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"bdf99lAQSJLuJR79SBJsE50","Close",20],[8,"cc.AudioSource","play",2]],[4,4292269782],-302,64,65,66,67]],[1,0,-450,0]],[5,"Title",33554432,21,[[2,-305,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,90]],[28,"LỊCH SỬ",50,50,1,false,true,-306,[0,"2frm37uaJHQr0AEEaYyM82"],68],[32,-307,[4,4289425681]],[33,-308,[4,4283776010],[0,0,-2]]],[1,0,325,0]],[90,"Overlay",false,33554432,11,[[2,-309,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1500]],[26,0,-310,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3221225472],69],[10,45,20,20,-311]]],[21,"Background",33554432,1,[12,22],[[2,-312,[0,"f7NISe7HdAD68SLfhnddy8"],[5,1128,1500]],[24,0,-313,[0,"e71ctEmpxFC4KlSYRZNz/a"],91]]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[6,["7aFiDHn+NClKHPLQ2dj3zj"]],[25,"Light",33554432,13,[-317],[[[7,-314,[5,670,670]],[20,-315,100],-316],4,4,1],[1,0,50,0]],[138,"main",[-318,-319,3],[106,[]],[139,[140],[141,[4,4283190348]],[142],[143]]],[67,"Border",33554432,14,[[2,-320,[0,"f7NISe7HdAD68SLfhnddy8"],[5,694,770]],[29,1,0,-321,[0,"e71ctEmpxFC4KlSYRZNz/a"],2],[30,18,275,275,572,572,200,190,-322]],[1,0.9,0.9,0.9]],[67,"Border",33554432,10,[[2,-323,[0,"f7NISe7HdAD68SLfhnddy8"],[5,694,636]],[29,1,0,-324,[0,"e71ctEmpxFC4KlSYRZNz/a"],13],[30,18,275,275,572,572,200,190,-325]],[1,0.9,0.9,0.8]],[5,"Label",33554432,25,[[2,-326,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,105]],[28,"Chia sẻ với bạn bè",25,25,1,false,true,-327,[0,"2frm37uaJHQr0AEEaYyM82"],20],[55,45,5,42.26,50.4,-328]],[1,0,2.5,0]],[40,"Particle",33554432,4,[[-329,[2,-330,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-331,[0,"50bRhRSqFKc4o+eXu3VyY/"]]],1,4,4],[1,0,-780,0],[1,50,50,50]],[17,"Border",33554432,6,[[2,-332,[0,"f7NISe7HdAD68SLfhnddy8"],[5,624,550]],[29,1,0,-333,[0,"e71ctEmpxFC4KlSYRZNz/a"],30],[30,18,275,275,572,572,200,190,-334]]],[36,"Value",33554432,16,[[[2,-335,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,66]],-336,[10,45,42.26,50.4,-337]],4,1,4]],[36,"Value",33554432,47,[[[2,-338,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,66]],-339,[10,45,42.26,50.4,-340]],4,1,4]],[5,"Label",33554432,26,[[2,-341,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,105]],[28,"Xác Nhận",25,25,1,false,true,-342,[0,"2frm37uaJHQr0AEEaYyM82"],38],[55,45,5,42.26,50.4,-343]],[1,0,2.5,0]],[5,"Label",33554432,17,[[2,-344,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,75]],[28,"Chia sẻ",25,25,1,false,true,-345,[0,"2frm37uaJHQr0AEEaYyM82"],40],[55,45,35,42.26,50.4,-346]],[1,0,17.5,0]],[5,"Label-001",33554432,17,[[2,-347,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,50.4]],[28,"Nhận thêm lượt chơi miển phí",15,15,1,false,true,-348,[0,"2frm37uaJHQr0AEEaYyM82"],41],[74,41,38.937,47.3,42.26,50.4,-349]],[1,0,-9.136999999999997,0]],[35,"Message",33554432,51,[[[2,-350,[0,"c68UOAlNhN171Umca6yVvF"],[5,564,320]],-351,[120,45,30,30,100,30,600,500,1,-352]],4,1,4],[1,0,-35,0]],[21,"Container",33554432,55,[-354,-355],[[2,-353,[0,"3242DVCWtMepBNxixN/wo6"],[5,616,94]]]],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[5,"Item1",33554432,22,[[2,-356,[0,"f7NISe7HdAD68SLfhnddy8"],[5,178,139]],[42,-357,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3238002687],87]],[1,-226.881,346.545,0]],[68,"Item2",33554432,22,[[2,-358,[0,"f7NISe7HdAD68SLfhnddy8"],[5,124,121]],[42,-359,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3238002687],88]],[1,251.767,612.541,0],[3,0,0,0.49999999999999994,0.8660254037844387],[1,0.8,0.8,0.8],[1,0,0,60]],[91,"Item3",33554432,22,[[2,-360,[0,"f7NISe7HdAD68SLfhnddy8"],[5,124,121]],[42,-361,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1090519039],89]],[1,-204.778,429.592,0],[1,0.5,0.5,0.5]],[68,"Item4",33554432,22,[[2,-362,[0,"f7NISe7HdAD68SLfhnddy8"],[5,178,139]],[42,-363,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1090519039],90]],[1,236.11,318.119,0],[3,0,0,0.49999999999999994,0.8660254037844387],[1,0.3,0.3,0.5],[1,0,0,60]],[101,"Overlay",false,33554432,13,[[[2,-364,[0,"f7NISe7HdAD68SLfhnddy8"],[5,1128,1500]],-365,[27,-366]],4,1,4]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[5,"Label",33554432,15,[[2,-367,[0,"07QMd0h1dLcYd/vjigaip6"],[5,359,100]],[132,"QUAY",60,60,1,false,false,true,-368,[0,"ee3IZdy2dLIaAWpjI7P0FL"],110],[74,45,17,65,100,40,-369]],[1,0,24,0]],[40,"ConfettiDrop",33554432,1,[[-370,[2,-371,[0,"ddSgXMDiVKSacEptWKUQGZ"],[5,1,1]],[44,-372,[0,"50bRhRSqFKc4o+eXu3VyY/"]]],1,4,4],[1,0,760,0],[1,50,50,50]],[92,"GameMgr","cfnugoLNRBn4krmo0no0Tq",66,[-383],[[144,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373]]],[93,"Audios",94,[2],[[145,true,-384,0]]],[17,"Icon",33554432,36,[[2,-385,[0,"f7NISe7HdAD68SLfhnddy8"],[5,84,84]],[24,0,-386,[0,"e71ctEmpxFC4KlSYRZNz/a"],7]]],[102,"GiftIcon",33554432,10,[[[2,-387,[0,"f7NISe7HdAD68SLfhnddy8"],[5,200,200]],-388],4,1],[1,1.5,1.5,1.5]],[17,"Icon",33554432,39,[[2,-389,[0,"f7NISe7HdAD68SLfhnddy8"],[5,84,84]],[24,0,-390,[0,"e71ctEmpxFC4KlSYRZNz/a"],15]]],[57,false,false,40,[0,"0b7a7v3FVOCpzmec7amMlB"],[[23,null],6,0],[15],[9,1],[1],[1],[4,3,40,70],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,2,3],[9,5],[1],[1],[[59,0.01,[9,20]]],[46,[15]],[60,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,-7.5]],[47,true,[58,1,-392],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[61,true,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[62,true,0.21,[1],[1],[1],[4,3,0.5,1]],[49,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[15],[15],-391],[52,24]],[77,2,8,[[78,1],[63,0.78,1],[152,0.99]]],[57,false,false,70,[0,"0b7a7v3FVOCpzmec7amMlB"],[[25,null],6,0],[15],[9,1],[1],[1],[4,3,40,70],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,2,3],[9,5],[1],[1],[[59,0.01,[9,20]]],[46,[15]],[60,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,0]],[47,true,[58,1,100],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[61,true,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[62,true,0.21,[1],[1],[1],[4,3,0.5,1]],[49,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[15],[15],-393],[52,26]],[57,false,false,41,[0,"0b7a7v3FVOCpzmec7amMlB"],[[27,null],6,0],[15],[9,1],[1],[1],[4,3,40,70],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,2,3],[9,5],[1],[1],[[59,0.01,[9,20]]],[46,[15]],[60,true,0,0.01,0.20943951023931956,[9,1],[1,90,0,7.5]],[47,true,[58,1,100],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[61,true,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[62,true,0.21,[1],[1],[1],[4,3,0.5,1]],[49,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[15],[15],-394],[52,28]],[17,"Icon",33554432,49,[[2,-395,[0,"f7NISe7HdAD68SLfhnddy8"],[5,84,84]],[24,0,-396,[0,"e71ctEmpxFC4KlSYRZNz/a"],44]]],[17,"Icon",33554432,52,[[2,-397,[0,"f7NISe7HdAD68SLfhnddy8"],[5,84,84]],[24,0,-398,[0,"e71ctEmpxFC4KlSYRZNz/a"],51]]],[17,"Bg",33554432,55,[[2,-399,[0,"f7NISe7HdAD68SLfhnddy8"],[5,616,94]],[26,0,-400,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294965740],58]]],[5,"Name",33554432,78,[[13,-401,[0,"c68UOAlNhN171Umca6yVvF"],[5,450,94],[0,0,0.5]],[133,"QUÀ NHẬN ĐƯỢC",0,30,30,30,1,false,false,true,-402,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],59]],[1,-280,0,0]],[5,"Time",33554432,78,[[13,-403,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,94],[0,0,0.5]],[134,"NGÀY",0,30,30,30,1,false,true,-404,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],60]],[1,200,0,0]],[35,"bar",33554432,29,[[[13,-405,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,3,156.25],[0,0,0]],-406],4,1],[1,-4,-31.25,0]],[17,"Icon",33554432,58,[[2,-407,[0,"f7NISe7HdAD68SLfhnddy8"],[5,84,84]],[24,0,-408,[0,"e71ctEmpxFC4KlSYRZNz/a"],63]]],[5,"MyTour",33554432,11,[[7,-409,[5,242,57]],[20,-410,70]],[1,0,45,0]],[5,"Dot1",33554432,7,[[7,-411,[5,13,17]],[20,-412,71]],[1,-63.5,0,0]],[5,"Dot2",33554432,7,[[7,-413,[5,13,17]],[20,-414,72]],[1,-45.5,0,0]],[5,"Dot3",33554432,7,[[7,-415,[5,13,17]],[20,-416,73]],[1,-27.5,0,0]],[5,"Dot4",33554432,7,[[7,-417,[5,13,17]],[20,-418,74]],[1,-9.5,0,0]],[5,"Dot5",33554432,7,[[7,-419,[5,13,17]],[20,-420,75]],[1,8.5,0,0]],[5,"Dot6",33554432,7,[[7,-421,[5,13,17]],[20,-422,76]],[1,26.5,0,0]],[5,"Dot7",33554432,7,[[7,-423,[5,13,17]],[20,-424,77]],[1,44.5,0,0]],[5,"Dot8",33554432,7,[[7,-425,[5,13,17]],[20,-426,78]],[1,62.5,0,0]],[5,"DogBig",33554432,11,[[7,-427,[5,17,21]],[20,-428,79]],[1,-60,0,0]],[17,"Icon",33554432,30,[[2,-429,[0,"f7NISe7HdAD68SLfhnddy8"],[5,48,73]],[24,0,-430,[0,"e71ctEmpxFC4KlSYRZNz/a"],82]]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-431,[153,"5aeUzVRlFJQZwGUuPvpQPa",null,[[154,[null],[6,["b2fdGMTRlIcIXQiFGMJj1n"]]]],[[155,"Light1",["_name"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]]],[19,["_lpos"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[1,-350,-900,0]],[19,["_lrot"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[3,0,0,0,1]],[19,["_euler"],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[1,0,0,0]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]],[19,["_fillCenter"],[6,["e71ctEmpxFC4KlSYRZNz/a"]],[0,0.5,0]]]],83]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-432,[16,"daVT4GV0pP97P9rhpgvSx7",[[11,"Light2",["_name"],79],[3,["_lpos"],79,[1,-100,-900,0]],[3,["_lrot"],79,[3,0,0,0,1]],[3,["_euler"],79,[1,0,0,0]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],84]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-436,[16,"f0nuBd9YdH6qRKlBur5gXY",[[11,"Light3",["_name"],-433],[3,["_lpos"],-434,[1,100,-900,0]],[3,["_lrot"],-435,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],85]],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[12,12,[14,"b2fdGMTRlIcIXQiFGMJj1n",-440,[16,"33B3OWAiVASJNK8464HR5/",[[11,"Light4",["_name"],-437],[3,["_lpos"],-438,[1,350,-900,0]],[3,["_lrot"],-439,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0.1]]]],86]],[6,["b2fdGMTRlIcIXQiFGMJj1n"]],[36,"Text1",33554432,23,[[[13,-441,[0,"c68UOAlNhN171Umca6yVvF"],[5,106.9,50.4],[0,0,0.5]],-442],4,1]],[36,"Text2",33554432,23,[[[13,-443,[0,"c68UOAlNhN171Umca6yVvF"],[5,106.9,50.4],[0,0,0.5]],-444],4,1]],[17,"Icon",33554432,31,[[2,-445,[0,"f7NISe7HdAD68SLfhnddy8"],[5,122,141]],[24,0,-446,[0,"e71ctEmpxFC4KlSYRZNz/a"],93]]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-447,[16,"326+nkc0hO36x0TSXjkFcL",[[11,"ItemNotification",["name"],62],[3,["rotation"],62,[3,0,0,0,1]],[11,"ItemNotification",["_name"],62],[3,["_lpos"],62,[1,0,135,0]],[3,["_lrot"],62,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],94]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-448,[16,"69Qvi4tOZGkZcPQ4lkWdQ1",[[11,"ItemNotification",["name"],63],[3,["rotation"],63,[3,0,0,0,1]],[11,"ItemNotification",["_name"],63],[3,["_lpos"],63,[1,0,90,0]],[3,["_lrot"],63,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],95]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-449,[16,"d4nlBWj2hLWK7bsk3BLsoA",[[11,"ItemNotification",["name"],64],[3,["rotation"],64,[3,0,0,0,1]],[11,"ItemNotification",["_name"],64],[3,["_lpos"],64,[1,0,45,0]],[3,["_lrot"],64,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],96]],[12,24,[14,"7aFiDHn+NClKHPLQ2dj3zj",-450,[16,"71mBAiiERGEb8A2EprXYvV",[[11,"ItemNotification",["name"],32],[3,["position"],32,[1,0,0,0]],[3,["rotation"],32,[3,0,0,0,1]],[11,"ItemNotification",["_name"],32],[3,["_lpos"],32,[1,0,0,0]],[3,["_lrot"],32,[3,0,0,0,1]],[19,["_anchorPoint"],[6,["f7NISe7HdAD68SLfhnddy8"]],[0,0.5,0]]]],97]],[5,"Base",33554432,13,[[2,-451,[0,"f7NISe7HdAD68SLfhnddy8"],[5,892,486]],[37,-452,[0,"e71ctEmpxFC4KlSYRZNz/a"],98]],[1,0,-370,0]],[5,"Spin",33554432,13,[[2,-453,[0,"f7NISe7HdAD68SLfhnddy8"],[5,640,640]],[37,-454,[0,"e71ctEmpxFC4KlSYRZNz/a"],99]],[1,0,50,0]],[36,"On",33554432,65,[[[7,-455,[5,710,710]],-456],4,1]],[5,"Gift",33554432,13,[[2,-457,[0,"f7NISe7HdAD68SLfhnddy8"],[5,653,250]],[37,-458,[0,"e71ctEmpxFC4KlSYRZNz/a"],101]],[1,19,-350,0]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-462,[16,"b2bNXMqyhFFbm3cJdMADUT",[[11,"ItemSpin1",["_name"],-459],[3,["_lpos"],-460,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],-461,[3,0,0,0,1]]]],102]],[6,["3empOM9gJKLaiwBBtK/4Le"]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-463,[16,"eftggHp71N6Id3jQvnV4Yp",[[11,"ItemSpin2",["_name"],85],[3,["_lpos"],85,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],85,[3,0,0,-0.3826834323650898,0.9238795325112867]],[3,["_euler"],85,[1,0,0,-45]]]],103]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-464,[16,"39XwOZJJNP55MRXiDBChDX",[[11,"ItemSpin3",["_name"],86],[3,["_lpos"],86,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],86,[3,0,0,-0.7071067811865475,0.7071067811865476]],[3,["_euler"],86,[1,0,0,-90]]]],104]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-465,[16,"0d2xPjlcFJbbKm1VRlcDLy",[[11,"ItemSpin4",["_name"],87],[3,["_lpos"],87,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],87,[3,0,0,-0.9238795325112867,0.38268343236508984]],[3,["_euler"],87,[1,0,0,-135]]]],105]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-466,[16,"562/uFHnlHXrCSaKh9Uy5K",[[11,"ItemSpin5",["_name"],88],[3,["_lpos"],88,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],88,[3,0,0,-1,6.123233995736766e-17]],[3,["_euler"],88,[1,0,0,-180]]]],106]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-467,[16,"f2xbVz3mlJT7Wwb78K2U7D",[[11,"ItemSpin6",["_name"],89],[3,["_lpos"],89,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],89,[3,0,0,-0.9238795325112867,-0.3826834323650897]],[3,["_euler"],89,[1,0,0,-225]]]],107]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-468,[16,"1cFJ9NhTpHUJJoAGMtCJqr",[[11,"ItemSpin7",["_name"],90],[3,["_lpos"],90,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],90,[3,0,0,-0.7071067811865476,-0.7071067811865475]],[3,["_euler"],90,[1,0,0,-270]]]],108]],[12,8,[14,"3empOM9gJKLaiwBBtK/4Le",-469,[16,"08vKO/zSRCmIAurg4s7VOs",[[11,"ItemSpin8",["_name"],91],[3,["_lpos"],91,[1,-0.3140000000000214,48.29399999999998,0]],[3,["_lrot"],91,[3,0,0,-0.3826834323650899,-0.9238795325112867]],[3,["_euler"],91,[1,0,0,-315]]]],109]],[35,"Turns",33554432,15,[[[2,-470,[0,"4bf4SjaRxP4KcluNxRvaJw"],[5,177.67000000000002,50.4]],-471],4,1],[1,0,-35,0]],[5,"Logo",33554432,1,[[2,-472,[0,"f7NISe7HdAD68SLfhnddy8"],[5,585,197]],[24,0,-473,[0,"e71ctEmpxFC4KlSYRZNz/a"],112]],[1,0,490,0]],[147,1000,93,[0,"0b7a7v3FVOCpzmec7amMlB"],[[113,null],6,0],[15],[9,0.75],[1],[1],[9,-0.1],[1],[1],[4,3,-3.141592653589793,6.283185307179586],[1],[4,3,5,10],[9,0.1],[9,5],[1],[46,[15]],[149,true,0,0.01,0.20943951023931956,[9,1],[1,25,0.2,25]],[47,true,[148,1,[77,2,8,[[78,1],[63,0.69,1],[63,1,-0.01]]]],[1],[1],[1]],[48,[1],[1],[1],[9,1]],[150,[4,3,0.3,-0.3],[4,3,0.3,-0.3],[4,3,0.3,-0.3]],[151,0.21,[1],[1],[1],[4,3,0.5,1]],[49,true,[1],[1],[4,3,-3.141592653589793,3.141592653589793]],[50,true,3,3,1,true,1,[45,3,8],[1]],[51,[9,1],[1],[15],[15],-474],[52,114]],[94,"Main Camera","c9DMICJLFO5IeO07EPon7U",66,[[156,1822425087,-475,[4,4284690175]]],[1,-10,10,10],[3,-0.27781593346944056,-0.36497167621709875,-0.11507512748638377,0.8811195706053617],[1,-35,-45,0]],[146,false,2],[158,1,149],[104,"Camera",3,[-476],[1,0,0,1000]],[157,0,1073741824,750,2000,6,41943040,153,[4,4284690175]],[159,9,14],[41,2,97,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[160,4,10,156,[99,101,102]],[56,"5",50,50,1,false,72,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4278190335]],[31,3,0.9,45,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Minus",5],[8,"cc.AudioSource","play",2]],[4,4292269782],45],[31,3,0.9,46,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Add",5],[8,"cc.AudioSource","play",2]],[4,4292269782],46],[56,"5",50,50,1,false,73,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4278190335]],[31,3,0.9,26,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"b495dvYo/BJlKfocklL9tQG","Exchange",5],[8,"cc.AudioSource","play",2]],[4,4292269782],26],[161,5,6,159,160,162,158,161],[56,"Error here",30,30,1,false,77,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4283914071]],[162,18,19,164],[110,1,0,108,[0,"02Vchn8fFF/77B+7pVCQuQ"],[4,4284888063]],[163,1,29,[0,"f4i77UV0dH4pcD0KQOXx7c"],166],[164,0.23,0.75,false,28,[0,"a8UaPDxYhIX5MrqvKGMJdR"],56,167],[165,20,21,56],[166,11,60],[31,3,0.9,30,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","Exit",1]],[4,4292269782],30],[76,"scrolling text",0,18,18,false,true,127,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4278190080]],[76,"scrolling text",0,18,18,false,true,128,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4278190080]],[167,23,172,173],[31,3,0.9,31,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","History",1]],[4,4292269782],31],[111,0,84,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,0]],[112,3,2,136,[0,0.5,0.5]],[168,65,177],[169,13,178,[138,140,141,142,143,144,145,146]],[170,"<color=#0b3b59>Còn lại</color><color=#ff245f> 0 </color><color=#0b3b59>lượt</color>",1,28,false,147,[0,"b5LFduq8VJWo/DE4BRFmBn"]],[31,3,0.9,15,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[8,"418ddTz9+lC7bF5livsSJvo","Spin",1]],[4,4292269782],15]],0,[0,0,1,0,-2,152,0,0,1,0,-1,61,0,-2,23,0,-3,31,0,-4,24,0,-5,13,0,-6,15,0,-7,148,0,-8,93,0,-1,151,0,0,3,0,22,154,0,0,3,0,0,3,0,-1,153,0,-3,9,0,-4,4,0,-5,5,0,-6,18,0,-7,20,0,-8,11,0,-9,30,0,0,4,0,0,4,0,-3,157,0,-1,37,0,-2,10,0,-3,40,0,-4,70,0,-5,41,0,0,5,0,-2,163,0,0,5,0,-1,42,0,-2,6,0,0,6,0,0,6,0,-1,71,0,-2,43,0,-3,16,0,-4,47,0,-5,26,0,-6,17,0,-7,49,0,0,7,0,0,7,0,-1,111,0,-2,112,0,-3,113,0,-4,114,0,-5,115,0,-6,116,0,-7,117,0,-8,118,0,0,8,0,-1,138,0,-2,140,0,-3,141,0,-4,142,0,-5,143,0,-6,144,0,-7,145,0,-8,146,0,0,9,0,0,9,0,-3,155,0,-1,33,0,-2,14,0,0,10,0,0,10,0,-1,68,0,-2,38,0,-3,97,0,-4,39,0,-5,25,0,0,11,0,0,11,0,0,11,0,-4,170,0,-1,60,0,-2,110,0,-4,119,0,0,12,0,0,12,0,0,12,0,-1,121,0,-2,122,0,-3,123,0,-4,125,0,0,12,0,-1,121,0,-2,122,0,-3,123,0,-4,125,0,0,13,0,-2,179,0,-1,134,0,-2,135,0,-3,84,0,-4,65,0,-5,137,0,0,14,0,0,14,0,-1,67,0,-2,34,0,-3,35,0,-4,36,0,0,15,0,0,15,0,-3,181,0,0,15,0,-1,92,0,-2,147,0,0,16,0,0,16,0,-1,44,0,-2,72,0,-3,45,0,-4,46,0,0,17,0,0,17,0,7,17,0,0,17,0,-1,75,0,-2,76,0,0,18,0,0,18,0,-3,165,0,-1,50,0,-2,19,0,0,19,0,0,19,0,-1,51,0,-2,52,0,-3,53,0,0,20,0,0,20,0,-3,169,0,-1,54,0,-2,21,0,0,21,0,0,21,0,-1,27,0,-2,58,0,-3,59,0,0,22,0,-1,80,0,-2,81,0,-3,82,0,-4,83,0,0,22,0,-1,80,0,-2,81,0,-3,82,0,-4,83,0,0,23,0,0,23,0,0,23,0,-4,174,0,-1,127,0,-2,128,0,0,24,0,-1,130,0,-2,131,0,-3,132,0,-4,133,0,0,24,0,-1,130,0,-2,131,0,-3,132,0,-4,133,0,0,25,0,0,25,0,7,25,0,0,25,0,-1,69,0,0,26,0,0,26,0,-3,162,0,-1,74,0,0,27,0,0,27,0,0,27,0,-1,55,0,-2,28,0,0,28,0,-2,168,0,0,28,0,-1,29,0,-2,57,0,0,29,0,0,29,0,0,29,0,-4,167,0,-1,108,0,0,30,0,-2,171,0,0,30,0,-1,120,0,0,31,0,-2,175,0,0,31,0,-1,129,0,0,33,0,0,33,0,0,33,0,0,33,0,0,34,0,0,34,0,7,34,0,0,34,0,0,35,0,0,35,0,7,35,0,0,35,0,0,36,0,7,36,0,0,36,0,-1,96,0,0,37,0,0,37,0,0,37,0,0,37,0,0,38,0,0,38,0,0,38,0,0,38,0,0,39,0,7,39,0,0,39,0,-1,98,0,-1,99,0,0,40,0,0,40,0,0,40,0,-1,102,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,42,0,0,43,0,0,43,0,0,43,0,0,43,0,0,44,0,0,44,0,0,44,0,0,44,0,0,45,0,0,45,0,-3,159,0,0,46,0,0,46,0,-3,160,0,0,47,0,0,47,0,-1,48,0,-2,73,0,0,48,0,0,48,0,0,48,0,0,48,0,0,49,0,7,49,0,0,49,0,-1,103,0,0,50,0,0,50,0,0,50,0,0,50,0,0,51,0,0,51,0,0,51,0,-1,77,0,0,52,0,7,52,0,0,52,0,-1,104,0,0,53,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,-1,105,0,-2,78,0,0,56,0,0,56,0,0,57,0,0,57,0,0,57,0,0,58,0,7,58,0,0,58,0,-1,109,0,0,59,0,0,59,0,0,59,0,0,59,0,0,60,0,0,60,0,0,60,0,0,61,0,0,61,0,0,65,0,0,65,0,-3,178,0,-1,136,0,-1,150,0,-2,94,0,0,67,0,0,67,0,0,67,0,0,68,0,0,68,0,0,68,0,0,69,0,0,69,0,0,69,0,-1,101,0,0,70,0,0,70,0,0,71,0,0,71,0,0,71,0,0,72,0,-2,158,0,0,72,0,0,73,0,-2,161,0,0,73,0,0,74,0,0,74,0,0,74,0,0,75,0,0,75,0,0,75,0,0,76,0,0,76,0,0,76,0,0,77,0,-2,164,0,0,77,0,0,78,0,-1,106,0,-2,107,0,0,80,0,0,80,0,0,81,0,0,81,0,0,82,0,0,82,0,0,83,0,0,83,0,0,84,0,-2,176,0,0,84,0,0,92,0,0,92,0,0,92,0,-1,149,0,0,93,0,0,93,0,23,151,0,24,169,0,25,163,0,26,157,0,27,155,0,28,165,0,29,170,0,30,174,0,31,152,0,0,94,0,-1,95,0,0,95,0,0,96,0,0,96,0,0,97,0,-2,156,0,0,98,0,0,98,0,14,99,0,32,100,0,14,101,0,14,102,0,0,103,0,0,103,0,0,104,0,0,104,0,0,105,0,0,105,0,0,106,0,0,106,0,0,107,0,0,107,0,0,108,0,-2,166,0,0,109,0,0,109,0,0,110,0,0,110,0,0,111,0,0,111,0,0,112,0,0,112,0,0,113,0,0,113,0,0,114,0,0,114,0,0,115,0,0,115,0,0,116,0,0,116,0,0,117,0,0,117,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,4,121,0,4,122,0,8,124,0,8,124,0,8,124,0,4,123,0,8,126,0,8,126,0,8,126,0,4,125,0,0,127,0,-2,172,0,0,128,0,-2,173,0,0,129,0,0,129,0,4,130,0,4,131,0,4,132,0,4,133,0,0,134,0,0,134,0,0,135,0,0,135,0,0,136,0,-2,177,0,0,137,0,0,137,0,8,139,0,8,139,0,8,139,0,4,138,0,4,140,0,4,141,0,4,142,0,4,143,0,4,144,0,4,145,0,4,146,0,0,147,0,-2,180,0,0,148,0,0,148,0,14,149,0,0,150,0,-1,154,0,33,66,1,9,3,2,9,95,3,9,66,7,9,11,8,9,13,12,9,61,22,9,61,56,9,57,152,34,171,152,35,175,152,36,181,152,37,180,152,38,176,152,39,179,167,40,168,476],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,151,158,159,160,161,162,164,166,169,171,172,173,175,176,177,180,180,181,152,152],[18,1,1,1,6,1,6,1,6,10,11,12,1,1,3,1,6,10,11,12,3,1,6,-1,15,-1,15,-1,15,1,1,3,3,1,1,1,3,1,3,1,3,3,1,6,1,6,10,11,12,1,1,1,6,10,11,12,3,1,1,3,3,1,1,1,6,10,11,12,3,1,1,1,1,1,1,1,1,1,1,1,-1,41,1,5,5,5,5,1,1,1,1,1,1,1,5,5,5,5,1,1,1,1,5,5,5,5,5,5,5,5,3,1,1,-1,15,18,3,6,6,3,6,3,1,42,6,3,3,6,1,1,3,43,6,44,45],[32,1,33,18,18,19,19,9,3,3,10,11,1,34,4,9,3,3,10,11,2,7,7,13,8,13,8,13,8,1,16,4,4,20,21,22,4,22,2,7,2,2,7,7,9,3,3,10,11,1,16,9,3,3,10,11,4,1,1,2,2,1,16,9,3,3,10,11,4,1,35,5,5,5,5,5,5,5,5,36,23,23,37,14,14,14,14,24,25,25,24,38,1,39,15,15,15,15,40,41,42,43,6,6,6,6,6,6,6,6,4,17,44,13,8,45,4,20,21,4,7,2,1,46,1,2,2,1,1,47,2,2,17,17,48]],[[{"name":"logo_vongquaymytour","rect":{"x":901,"y":1765,"width":585,"height":197},"offset":{"x":0,"y":0},"originalSize":{"width":585,"height":197},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"app_download","rect":{"x":1137,"y":733,"width":693,"height":728},"offset":{"x":0,"y":0},"originalSize":{"width":693,"height":728},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[79,"button_tap",".mp3",1.285063]],0,0,[],[],[]],[[{"name":"gift_front","rect":{"x":901,"y":1509,"width":653,"height":250},"offset":{"x":0,"y":0},"originalSize":{"width":653,"height":250},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"popup","rect":{"x":1807,"y":1801,"width":201,"height":167},"offset":{"x":0,"y":0},"originalSize":{"width":201,"height":167},"rotated":false,"capInsets":[80,100,95,55],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[39,"ItemGift"],[65,"ItemGift",33554432,[-8,-9],[[2,-2,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,616,122]],[171,-7,[0,"15V6KItCJGAIu1qnMu7KxT"],-6,-5,-4,-3]],[18,"80oVypFg9Ea5rK9ZuAfYlh",-1,0],[1,0,-141,0]],[95,"Container",33554432,1,[-11,-12,-13],[[2,-10,[0,"3242DVCWtMepBNxixN/wo6"],[5,616,122]]],[18,"2cAB3vm0dMyI7ZFgt7HE8v",1,0]],[69,"Bg",33554432,1,[[[2,-14,[0,"f7NISe7HdAD68SLfhnddy8"],[5,616,122]],-15],4,1],[18,"a8OMyFqFRGBqO1fu7Q0rmJ",1,0]],[53,"Icon",33554432,2,[[[2,-16,[0,"f7NISe7HdAD68SLfhnddy8"],[5,185,179]],-17],4,1],[18,"74ncfWgRxBVqtM2PvgcJT2",1,0],[1,-225,0,0]],[53,"Description",33554432,2,[[[13,-18,[0,"c68UOAlNhN171Umca6yVvF"],[5,320,94],[0,0,0.5]],-19],4,1],[18,"8aK+R4pM9M2YIhahqJqu60",1,0],[1,-140,0,0]],[53,"Time",33554432,2,[[[13,-20,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,94],[0,0,0.5]],-21],4,1],[18,"138ACOBEhDCJHTetcW3C00",1,0],[1,200,0,0]],[41,0,3,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[41,2,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[135,"Gift",0,25,25,30,1,false,false,5,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488]],[136,"02/07\n16:59",0,25,25,30,1,false,6,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488]]],0,[0,4,1,0,0,1,0,46,10,0,47,9,0,16,8,0,17,7,0,0,1,0,-1,3,0,-2,2,0,0,2,0,-1,4,0,-2,5,0,-3,6,0,0,3,0,-2,7,0,0,4,0,-2,8,0,0,5,0,-2,9,0,0,6,0,-2,10,0,13,1,21],[7,9,10],[1,3,3],[1,2,2]],[[[79,"bgm",".mp3",33.645714]],0,0,[],[],[]],[[{"name":"btt_spin_b","rect":{"x":1807,"y":368,"width":359,"height":182},"offset":{"x":0,"y":0},"originalSize":{"width":359,"height":182},"rotated":true,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_lightoff","rect":{"x":3,"y":719,"width":670,"height":670},"offset":{"x":0,"y":0},"originalSize":{"width":670,"height":670},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[[172,"builtin-particle",[{"hash":1755172438,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3314483928,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":3916783067,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":1118626722,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":37}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[{"name":"btt_minus","rect":{"x":1744,"y":1467,"width":54,"height":58},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":58},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"btt_back","rect":{"x":1995,"y":3,"width":48,"height":73},"offset":{"x":0,"y":0},"originalSize":{"width":48,"height":73},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[39,"ItemNotification"],[96,"ItemNotification",33554432,[-6],[[13,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,550,50],[0,0.5,0]],[29,1,0,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[173,-5,[0,"88W+AM2qdM7YL43Rm/wu6E"],-4]],[18,"7aFiDHn+NClKHPLQ2dj3zj",-1,0]],[69,"Label",33554432,1,[[[13,-7,[0,"c68UOAlNhN171Umca6yVvF"],[5,550,50],[0,0.5,0]],-8,[121,45,42.22,50.4,1,-9,[0,"cduD0aCNtBFK4RCCgUXAF2"]]],4,1,4],[18,"84yO6BiwFDMrUdCMsCSdJv",1,0]],[137,18,18,1,false,false,2,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281479730]]],0,[0,4,1,0,0,1,0,0,1,0,48,3,0,0,1,0,-1,2,0,0,2,0,-2,3,0,0,2,0,13,1,9],[0,3],[1,3],[49,2]],[[{"name":"white","rect":{"x":1413,"y":1968,"width":64,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":64,"height":64},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_loading_mytour","rect":{"x":1165,"y":1968,"width":242,"height":57},"offset":{"x":0,"y":0},"originalSize":{"width":242,"height":57},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"gift_behide","rect":{"x":3,"y":1509,"width":892,"height":486},"offset":{"x":0,"y":0},"originalSize":{"width":892,"height":486},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"icon_history","rect":{"x":1560,"y":1612,"width":122,"height":141},"offset":{"x":0,"y":0},"originalSize":{"width":122,"height":141},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_bluelight","rect":{"x":1492,"y":1765,"width":269,"height":309},"offset":{"x":21,"y":-3.5},"originalSize":{"width":311,"height":356},"rotated":true,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[{"name":"luckywheel_glowlight","rect":{"x":649,"y":1395,"width":311,"height":356},"offset":{"x":0,"y":0},"originalSize":{"width":311,"height":356},"rotated":false,"capInsets":[0,0,0,0],"texture":"17699fa08@6c48a","packable":true}],[0],0,[0],[2],[12]],[[{"name":"deco_voucher_2","rect":{"x":1836,"y":997,"width":124,"height":121},"offset":{"x":0,"y":0},"originalSize":{"width":124,"height":121},"rotated":false,"capInsets":[0,0,0,0],"texture":"1444b2a78@6c48a","packable":true}],[0],0,[0],[2],[0]],[[[174,[[175,"ShadowFlow",[[176,"ShadowStage"]]],[177,"ForwardFlow",1,[[178,"ForwardStage",[[179,["default"]],[180,true,1,["default"]]]]]]]]],0,0,[],[],[]]]]
