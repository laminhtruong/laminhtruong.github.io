[1,["13630127d@6c48a","e2uRISfu5MxLMoT+f2TEdu@f9941","20g1ukYUVPvKWKBRznAKo+@f9941","a1mseI+OhHy4jWJV7soaQU","efYa2cEIxLkaGAdDs6fyN4","3f+cYf8M1HWpC324nxVh5N","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","e00c0trElNk4ufxzKBASLR","4c2Jo8N7tNVYqSJiNJc2et@f9941","9ckP2qcZlP2bPf+Y7qZ7O9@f9941","f2LUIzTXFB27URp0wgzSfe@f9941","836yr8qLBBH6v4l45wp2l2@6c48a","c1FM5BFTRNp4jM6VCwwco7@f9941","dbNjFFYhRKl5xkklvnEX3H@f9941","0etiExXwtCpq7IYrVoYPKH@f9941","f0AoR8FedEXZYASxZ1Wc6E@f9941","34wKytGwFPTbrLblcA+KkR@f9941","66K5aVxgpJHoJygy0mPi9P@f9941","6cbK/oCIpDSbpIKEhrUrM+@f9941","2765WnSjVAC7Rlkq/KyMu/@f9941","05qO9sO0FOxZUZCVS40L7y@f9941","ee25pAN0tHFI+euKi7f291@f9941","efU7uV9HdINaMhbpJpraBo@f9941","66NN5kTAVOi6dJqkNwg/OP@f9941","11vcSwZKhOt6Knn7niM+l3@f9941","11vcSwZKhOt6Knn7niM+l3@6c48a","15jn5SMiBM15aUcT4OboJ4@6c48a","20g1ukYUVPvKWKBRznAKo+@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","d1NGQ2rJZCcbhjH0/erZWw","bcThKyaiJB7ZopbpOZNr9j@f9941","7203KokU9OlYwXRYWkJzGU@f9941","dcC6HP3ydHLJfxoxMy78gn@f9941","61VNIH+HFI1q3rtJjZ/Yo3@f9941","80N5KweQdLTrDnUnhhvjbT@f9941","969WVMeoRIt7JvKrq5OMI+","b1BcAel5RKmoZMk8uQLtRN@f9941","ffuIqPr2JI9I8dPLYGRDpD@f9941","2dCLtUJCRECbPU4x8uTCuh@f9941","b7MFJ8MjNBwqr3fNq1j5dJ@f9941","3a5kcRsFNL0pOcXFFFP6P3@f9941","efCKldfmNKcJL8z0MHYPuD@f9941","95sEPhj9BB16YxJNWg6eKP@f9941","d9X52i+6NC56sYEBRs69nq@f9941","afxHkx8GZGsJC+n+YfITQo@f9941","ecuz7bzftAm6AnkfNZNjgA","c4WU7Oc5ZE37KJhjLUU5Ik","c8NmJAJmRKCL2PjQD+QSIQ","15jn5SMiBM15aUcT4OboJ4@f9941","afxHkx8GZGsJC+n+YfITQo@6c48a","b7MFJ8MjNBwqr3fNq1j5dJ@6c48a","38uYmYiVdA6a6Rabxr/4KI@f9941","e46rC7+fBJTJh0vE5g/mWp@f9941","960lgHkVlMP6BvfY+w/hIL@f9941","90mzLIdApBYKpwc+DJgvN4@f9941","ffuIqPr2JI9I8dPLYGRDpD@6c48a"],["node","_spriteFrame","_font","_textureSource","_target","_normalSprite","targetInfo","root","_parent","_hoverSprite","_pressedSprite","_disabledSprite","asset","target","data","time","price","bg","mainTexture","_effectAsset","_cameraComponent","popupInformation","popupAgreement","popupError","loading","main","login","_particleSystem","scene","Price","TurnCount","BidName","Background","_verticalScrollBar","_handle","_scrollView","_mainTexture","PrefabWinner","PrefabBidding","PrefabProgram","description","thumnail","location","hotel","bgBlue","bgPink","information","winner"],["cc.SpriteFrame",["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_top","_bottom","_right","_left","_alignMode","node","__prefab"],-5,1,4],["cc.Node",["_name","_layer","_id","_active","_components","_parent","_lpos","_children","_prefab","_lscale","_lrot","_euler"],-1,9,1,5,2,4,5,5,5],["cc.Label",["_actualFontSize","_string","_overflow","_isSystemFontUsed","_fontSize","_horizontalAlign","_enableWrapText","_isBold","_lineHeight","_isItalic","_verticalAlign","node","__prefab","_color","_font"],-8,1,4,5,6],["cc.Node",["_name","_layer","_active","_components","_parent","_lpos","_children","_prefab","_lscale"],0,12,1,5,2,4,5],["cc.Sprite",["_sizeMode","_type","_enabled","node","__prefab","_spriteFrame","_color"],0,1,4,6,5],"cc.ImageAsset","cc.Texture2D",["cc.CurveRange",["mode","multiplier","constantMax","constantMin","constant","curve","curveMin","curveMax"],-2,4,4,4],["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.Keyframe",["time","value","inTangent","outTangent"],-1],["cc.Layout",["_resizeMode","_layoutType","_paddingLeft","_paddingRight","_spacingY","_spacingX","node","__prefab"],-3,1,4],["cc.Button",["_transition","_zoomScale","node","__prefab","_normalColor","_target","clickEvents","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],1,1,4,5,1,9,6,6,6,6],["cc.Mask",["_enabled","node","__prefab"],2,1,4],["cc.PrefabInfo",["fileId","targetOverrides","root","instance","asset"],2,9,1,4,6],["cc.Camera",["_visibility","_projection","_priority","_orthoHeight","_far","_clearFlags","node","_color"],-3,1,5],["cc.ScrollView",["bounceDuration","brake","vertical","elastic","horizontal","node","__prefab","_content","_verticalScrollBar"],-2,1,4,1,1],["cc.ScrollBar",["_direction","_enableAutoHide","node","__prefab","_scrollView","_handle"],1,1,4,1,1],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],["cc.TTFFont",["_name","_native"],1],["cc.Material",["_techIdx","_states","_defines","_props"],0,12],["cc.SceneAsset",["_name"],2],["cc.Node",["_name","_parent","_components","_lpos"],2,1,2,5],["cc.CompPrefabInfo",["fileId"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.BlockInputEvents",["node"],3,1],["abe62Rom6RGOZBhSfqtMLHb",["node","TimeDigits","Notifications"],3,1,2,2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.PrefabInfo",["fileId","root","asset"],2,1,1],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo"],2,1,1,4],["cc.TargetInfo",["localID"],2],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",[],3],["cc.UIMeshRenderer",["node"],3,1],["cc.PrefabInstance",["fileId","propertyOverrides"],2,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["2df67cPW6dPX48dJVTWAnOy",["node","login","main","bid","loading","popupError","popupAgreement","popupInformation"],3,1,1,1,1,1,1,1,1],["88819R1zIVFQawyuDuWo1i2",["node"],3,1],["cc.ParticleSystem",["startRotation3D","_capacity","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],1,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.GradientRange",[],3],["cc.Burst",["repeatInterval","count"],2,4],["cc.ColorOvertimeModule",["color"],3,4],["cc.ShapeModule",["_enable","_shapeType","emitFrom","radius","arcSpeed"],-1,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.AnimationCurve",["preWrapMode","postWrapMode","keyFrames"],1,9],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.LimitVelocityOvertimeModule",["_enable","dampen","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","cycleCount","randomRow","frameOverTime","startFrame"],-2,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["418ddTz9+lC7bF5livsSJvo",["node","BidName","Infomation","UserName","TurnCount","BiddingNode","BiddingContainer","BiddingMore","WinnerNode","WinnerContainer","WinnerMore","ProgramContainer","timeDigits","FloatingItems"],3,1,1,1,1,1,1,1,1,1,1,1,1,2,2],["cc.EditBox",["_inputMode","_maxLength","node","__prefab","_textLabel","_placeholderLabel"],1,1,4,1,1],["f2b2fXBSjhBZ4KwKnXZ/HX5",["node","icon"],3,1,1],["cd786OL4KtC4rtPw+E8R6+f",["node","message"],3,1,1],["cc.WebView",["_url","node","__prefab"],2,1,4],["cc.Toggle",["_isChecked","node","__prefab","_normalColor","_target","_checkMark"],2,1,4,5,1,1],["252de94ShdLxLFIQbxXPCxA",["node","webview","toggleAgree","buttonAgree"],3,1,1,1,1],["35d6e3+Q9ZO+4eI42f4ic39",["node","webview"],3,1,1],["cc.Prefab",["_name"],2],["29b29DhKDpPx6KKXVpIBp3Z",["node","__prefab","bg","time","description","price"],3,1,4,1,1,1,1],["7b38eim8h9B5ozHT5BG2m7Y",["node","__prefab","bgPink","bgBlue","time","hotel","location","thumnail"],3,1,4,1,1,1,1,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["45db9SjQ7xMLrjPwl8puXSz",["node","__prefab","information"],3,1,4,1],["3559aEckTBCrqIgOqHLWCp2",["node","__prefab","bg","time","winner","price"],3,1,4,1,1,1,1],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[23,0,2],[9,0,2,1,1],[2,0,1,5,4,6,3],[9,0,2,1,3,1],[2,0,1,5,7,4,6,3],[5,3,4,5,1],[2,0,1,5,4,3],[4,0,1,4,3,5,3],[29,0,1,2,2],[9,0,1,1],[5,1,0,3,4,5,3],[1,0,1,2,8,4],[31,0,2],[40,0,1,2,2],[5,0,3,4,6,5,2],[25,0,1,2,3],[8,1],[3,1,0,4,2,3,7,11,12,13,7],[4,0,1,4,3,7,5,3],[12,0,1,2,3,6,4,5,7,8,9,10,3],[14,0,2,3,4,2],[38,0,1,2],[39,0,1,2,3],[5,0,3,4,5,2],[1,0,3,8,3],[2,0,1,5,7,4,3],[9,0,1,3,1],[5,3,5,1],[1,0,6,5,3,4,1,2,8,8],[8,0,3,2,4],[9,0,2,1],[1,0,3,1,8,4],[3,1,0,2,6,11,12,13,5],[8,0,2,3],[50,0,1,2,3],[10,1,2],[10,0,2],[2,0,1,7,4,6,3],[2,5,8,1],[2,8,1],[4,0,2,4,6,3,3],[5,0,3,4,2],[1,0,1,8,3],[1,0,3,4,1,2,8,6],[1,0,6,5,4,1,2,7,8,8],[12,0,1,2,3,6,4,5,7,3],[26,0,1],[30,0,1,2,3,2],[3,1,0,4,2,3,7,11,12,14,7],[3,1,0,4,8,2,3,11,12,13,14,7],[41,0,1,2,2],[45,1],[8,4,2],[66,0,2],[19,0,1,3],[2,0,1,5,4,6,9,3],[2,0,1,7,4,8,6,3],[4,0,1,6,3,5,3],[4,0,1,4,6,3,5,3],[9,0,1],[5,1,0,3,4,3],[1,0,6,5,3,1,8,6],[1,0,8,2],[13,1,1],[3,1,5,0,4,8,2,3,11,12,13,14,8],[3,1,5,0,4,8,2,3,11,12,13,8],[3,1,5,0,4,8,2,11,12,13,7],[2,0,1,7,4,3],[2,0,5,7,4,6,2],[2,0,5,4,6,2],[2,0,1,5,7,4,8,3],[2,0,1,5,4,8,6,3],[4,0,4,6,3,2],[4,0,1,4,3,7,3],[5,3,6,5,1],[11,0,1,6,3],[11,0,1,2,3,6,7,5],[11,0,1,6,7,3],[1,0,8,9,2],[1,0,1,2,7,8,5],[1,0,5,4,7,8,5],[1,0,5,3,8,4],[1,0,2,7,8,9,4],[1,0,4,1,2,8,5],[1,0,1,2,8,9,4],[1,0,6,5,4,1,8,9,6],[12,0,1,2,3,6,4,5,3],[3,1,5,0,4,2,3,7,11,12,13,14,8],[3,1,0,4,2,6,11,12,6],[3,1,0,4,2,3,7,11,12,7],[3,1,5,0,4,2,6,3,11,12,8],[8,0,1,5,3],[8,1,2],[10,0,1,3],[62,0,1,2,2],[20,0,1,2,3,4],[21,0,2],[2,0,1,2,7,4,6,4],[2,0,1,7,4,6,9,3],[2,0,1,4,6,3],[2,0,1,5,7,4,6,9,3],[2,0,1,5,4,10,11,3],[2,0,2,5,4,6,10,11,3],[2,0,2,5,4,3],[2,0,3,1,5,4,8,6,4],[2,0,1,7,4,8,3],[4,0,4,6,3,5,2],[4,0,1,4,6,3,3],[4,0,2,1,4,3,5,8,4],[4,0,2,1,4,3,5,4],[4,0,1,4,3,3],[4,0,2,1,4,3,4],[22,0,1,2,3,2],[5,1,3,2],[5,2,1,0,3,4,6,5,4],[5,1,0,3,4,6,3],[5,0,3,4,6,2],[11,0,1,4,6,4],[11,0,1,2,3,5,6,6],[1,0,1,7,8,4],[1,0,5,3,4,8,5],[1,0,6,3,4,8,5],[1,0,6,8,9,3],[1,0,6,5,3,4,1,2,8,9,8],[1,0,5,4,8,9,4],[1,0,6,3,1,2,8,9,6],[24,0,1,2,1],[12,0,1,2,3,4,5,3],[13,0,1,2,2],[13,1,2,1],[27,0,1,2,1],[28,0,1,2,3,2],[14,1,1],[32,0,1,2,3,1],[33,1],[34,0,1],[35,1],[36,1],[3,1,0,2,6,3,7,11,12,14,7],[3,1,0,2,6,11,12,5],[3,1,5,0,4,2,3,11,12,13,14,7],[3,1,5,0,4,3,7,11,12,13,14,7],[3,1,5,0,4,3,9,11,12,13,14,7],[3,1,5,0,4,2,11,12,6],[3,1,0,2,3,7,11,12,13,6],[3,1,5,0,8,2,6,3,11,12,13,8],[3,1,0,2,11,12,4],[3,1,0,4,2,3,11,12,6],[3,1,5,10,0,4,8,2,3,11,12,9],[3,5,0,4,2,6,3,11,12,13,7],[37,0,1],[15,0,6,2],[15,1,2,3,4,5,0,6,7,7],[42,0,1,2,3,4,5,6,7,1],[43,0,1],[44,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,3],[8,0,5,2],[8,0,2],[8,0,1,6,7,3],[46,0,1,2],[47,0,1],[48,0,1,2,3,4,5],[49,0,1,2,3,4,2],[10,0,2,3],[10,0,1,2,3,5],[10,0,1,2,4],[51,0,1,2,3,1],[52,0,1,2,1],[53,0,1,2,3,4,5,3],[54,0,1,2,3,2],[55,0,1,2,3,4,5,6,6],[56,0,1,2,3,4,1],[57,0,1],[16,0,1,2,5,6,7,4],[16,0,3,4,5,6,7,8,4],[17,0,2,3,4,2],[17,0,1,2,3,5,3],[58,0,1,2,3,4,5,6,7,8,9,10,11,12,13,1],[59,0,1,2,3,4,5,3],[60,0,1,1],[61,0,1,1],[63,0,1,2,3,4,5,2],[64,0,1,2,3,1],[65,0,1,1],[67,0,1,2,3,4,5,1],[68,0,1,2,3,4,5,6,7,1],[69,0,1,2,4],[70,0,1,2,1],[71,0,1,2,3,4,5,1],[72,0,1],[73,0,1,2],[74,0,2],[75,0,1,2,3],[76,0,1,2],[18,0,2],[18,1,2,0,4]],[[[{"name":"cacbuocthamgia_board_blue","rect":{"x":787,"y":1622,"width":200,"height":190},"offset":{"x":0,"y":0},"originalSize":{"width":200,"height":190},"rotated":true,"capInsets":[60,60,60,60],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"mainscreen_tophotel_board","rect":{"x":615,"y":1452,"width":587,"height":166},"offset":{"x":0,"y":0},"originalSize":{"width":587,"height":166},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["11vcSwZKhOt6Knn7niM+l3"]}],[7],0,[],[],[]],[[{"name":"default_toggle_normal","rect":{"x":0,"y":0,"width":28,"height":28},"offset":{"x":0,"y":0},"originalSize":{"width":28,"height":28},"rotated":false,"capInsets":[0,0,0,0],"texture":"11bdc4b0-64a8-4eb7-a2a7-9fb9e233e977@6c48a","packable":true}],[0],0,[0],[3],[26]],[[{"fmt":"0","w":1231,"h":2047}],[6],0,[],[],[]],[[{"base":"2,2,2,2,0,1","mipmaps":["13630127d"]}],[7],0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["15jn5SMiBM15aUcT4OboJ4"]}],[7],0,[],[],[]],[[{"name":"default_toggle_checkmark","rect":{"x":4,"y":5,"width":20,"height":18},"offset":{"x":0,"y":0},"originalSize":{"width":28,"height":28},"rotated":false,"capInsets":[0,0,0,0],"texture":"158e7e52-3220-4cd7-9694-713e0e6e8278@6c48a","packable":true}],[0],0,[0],[3],[27]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["20g1ukYUVPvKWKBRznAKo+"]}],[7],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"20835ba4-6145-4fbc-a58a-051ce700aa3e@6c48a","packable":true}],[0],0,[0],[3],[28]],[[{"name":"main_luotchoi_board","rect":{"x":983,"y":1818,"width":196,"height":75},"offset":{"x":0,"y":0},"originalSize":{"width":196,"height":75},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"cacbuocthamgia_inside","rect":{"x":3,"y":1128,"width":606,"height":568},"offset":{"x":0,"y":0},"originalSize":{"width":606,"height":568},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"mainscreen_timing_b","rect":{"x":3,"y":1702,"width":556,"height":173},"offset":{"x":0,"y":-1},"originalSize":{"width":560,"height":175},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"main_sapdaugia_mytour","rect":{"x":821,"y":70,"width":280,"height":423},"offset":{"x":0,"y":0},"originalSize":{"width":280,"height":423},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"auction_bottom_board","rect":{"x":3,"y":759,"width":750,"height":189},"offset":{"x":0,"y":0},"originalSize":{"width":750,"height":189},"rotated":false,"capInsets":[150,120,150,50],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[54,"helveticaneue","helveticaneue.ttf"]],0,0,[],[],[]],[[{"name":"COIN_MAIN","rect":{"x":422,"y":1966,"width":74,"height":71},"offset":{"x":0,"y":0},"originalSize":{"width":74,"height":71},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["54TknWPwVPqJqeCR+Y/Czo"]}],[7],0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"544e49d6-3f05-4fa8-9a9e-091f98fc2ce8@6c48a","packable":true}],[0],0,[0],[3],[29]],[[{"name":"icon_saleticket","rect":{"x":345,"y":1881,"width":196,"height":79},"offset":{"x":0,"y":0},"originalSize":{"width":196,"height":79},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"button_back","rect":{"x":345,"y":1966,"width":71,"height":78},"offset":{"x":0,"y":0},"originalSize":{"width":71,"height":78},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"white_128a","rect":{"x":1154,"y":1889,"width":64,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":64,"height":64},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"button_more_turn","rect":{"x":547,"y":1881,"width":62,"height":66},"offset":{"x":0,"y":0},"originalSize":{"width":62,"height":66},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"COIN_1","rect":{"x":499,"y":1966,"width":65,"height":71},"offset":{"x":0,"y":1},"originalSize":{"width":75,"height":75},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"icon_bid","rect":{"x":647,"y":1070,"width":124,"height":178},"offset":{"x":0,"y":0},"originalSize":{"width":124,"height":178},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["836yr8qLBBH6v4l45wp2l2"]}],[7],0,[],[],[]],[[{"name":"notification","rect":{"x":759,"y":759,"width":124,"height":51},"offset":{"x":0,"y":0},"originalSize":{"width":124,"height":51},"rotated":true,"capInsets":[60,0,30,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["95EkngnxZFbYuFpsqVTaFr"]}],[7],0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"texture":"951249e0-9f16-456d-8b85-a6ca954da16b@6c48a","packable":true}],[0],0,[0],[3],[30]],[[{"name":"button_auction","rect":{"x":1133,"y":3,"width":94,"height":100},"offset":{"x":0,"y":0},"originalSize":{"width":94,"height":100},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"main_sapdaugia_smallborder","rect":{"x":1064,"y":1908,"width":82,"height":82},"offset":{"x":0,"y":0},"originalSize":{"width":82,"height":82},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[95,1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[18,19],[12,31]],[[{"name":"button_pink","rect":{"x":1107,"y":776,"width":181,"height":111},"offset":{"x":0,"y":0},"originalSize":{"width":181,"height":111},"rotated":true,"capInsets":[50,0,50,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[54,"helveticaneuemedium","helveticaneuemedium.ttf"]],0,0,[],[],[]],[[[96,"main"],[37,"content",33554432,[-5,-6,-7,-8,-9,-10,-11,-12],[[3,-1,[0,"99yn0cfL9MmZYfJbPmK9qL"],[5,750,4098],[0,0.5,1]],[14,0,-2,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294953272],62],[117,1,2,20,-3],[42,41,220,-4]],[1,0,667,0]],[97,"Canvas",33554432,"0dDmbhkC9Ftb0hdJwrl+Yu",[-17,-18,-19,-20,-21,-22,-23,-24],[[1,-13,[0,"0dngp/9gNO34wUQjZfN/CX"],[5,750,1334]],[126,-15,[0,"3f2oTdCepERZdpmIfLsrhd"],-14],[78,45,-16,[0,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,375,667,0]],[72,"Main",2,[-28],[[[9,-25,[5,750,1334]],-26,[11,45,100,100,-27]],4,1,4]],[4,"Top",33554432,1,[-31,-32,-33,-34,-35,-36,-37,-38],[[1,-29,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1150]],[119,41,64,1,-30]],[1,0,-575,0]],[4,"Time",33554432,4,[-41,-42,-43,-44,-45,-46,-47,-48],[[9,-39,[5,750,250]],[24,41,748,-40]],[1,0,-298,0]],[98,"Time",33554432,[-51,-52,-53,-54,-55,-56,-57,-58],[[9,-49,[5,1071.4285714285716,250]],[24,41,10.5,-50]],[1,0,462,0],[1,0.7,0.7,0.7]],[40,"PopupAgreement",false,2,[-62,-63,-64,-65,-66,-67],[[[9,-59,[5,750,1334]],[79,45,100,100,0,-60],-61],4,4,1]],[25,"Floating",33554432,4,[-69,-70,-71,-72,-73,-74,-75,-76],[[59,-68]]],[4,"Bidding",33554432,1,[-80,-81,-82,-83],[[3,-77,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,600],[0,0.5,1]],[14,0,-78,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294953272],52],[31,41,2878,64,-79]],[1,0,-2878,0]],[4,"Winner",33554432,1,[-87,-88,-89,-90],[[3,-84,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,600],[0,0.5,1]],[14,0,-85,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294953272],61],[31,41,3498,64,-86]],[1,0,-3498,0]],[106,"Bid",2,[-94,-95,-96],[[[9,-91,[5,750,1334]],[43,45,-1334,1334,750,1334,-92],-93],4,4,1],[1,0,1334,0]],[4,"Bottom",33554432,11,[-99,-100,-101,6,-102,-103],[[3,-97,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,560],[0,0.5,0]],[42,4,750,-98]],[1,0,-667,0]],[40,"PopupInformation",false,2,[-107,-108,-109,-110],[[[9,-104,[5,750,1334]],[79,45,100,100,0,-105],-106],4,4,1]],[72,"Login",2,[-114,-115],[[[9,-111,[5,750,1334]],-112,[11,45,100,100,-113]],4,1,4]],[4,"Play",33554432,4,[-121,-122],[[1,-116,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,690,111]],[10,1,0,-117,[0,"77BcV1zfNHo4LI4KRqZupe"],16],[45,3,0.9,-119,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","Play",3]],[4,4292269782],-118,17],[24,1,1009.5,-120]],[1,0,-490,0]],[4,"NextPrograms",33554432,1,[-126,-127,-128,-129],[[3,-123,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,537],[0,0.5,1]],[14,0,-124,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294953272],34],[31,41,1420,64,-125]],[1,0,-1420,0]],[4,"Button",33554432,9,[-135],[[1,-130,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,120,120]],[60,1,0,-131,[0,"77BcV1zfNHo4LI4KRqZupe"]],[86,3,0.9,-133,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","ExpandBidding",3]],[4,4292269782],-132],[80,36,50,40,1,-134]],[1,265,-500,0]],[4,"Button",33554432,10,[-141],[[1,-136,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,120,120]],[60,1,0,-137,[0,"77BcV1zfNHo4LI4KRqZupe"]],[86,3,0.9,-139,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","ExpandBidding",3]],[4,4292269782],-138],[80,36,50,40,1,-140]],[1,265,-500,0]],[40,"PopupError",false,2,[-145,-146,-147],[[[9,-142,[5,750,1334]],[11,45,100,100,-143],-144],4,4,1]],[107,"ScrollView",33554432,3,[-152,-153],[[[1,-148,[0,"71kmounFRG/K27WWBbH2RB"],[5,750,1334]],[10,1,0,-149,[0,"8ce2Xg/B9GhY0DNafD/vxa"],64],-150,[11,45,240,250,-151]],4,4,1,4]],[4,"Rule",33554432,1,[-157,-158,-159],[[3,-154,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,815],[0,0.5,1]],[14,0,-155,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294953272],43],[42,40,64,-156]],[1,0,-2043,0]],[4,"Content",33554432,21,[-162,-163,-164,-165],[[3,-160,[0,"f7NISe7HdAD68SLfhnddy8"],[5,606,568],[0,0.5,1]],[5,-161,[0,"e71ctEmpxFC4KlSYRZNz/a"],42]],[1,0,-100,0]],[37,"content",33554432,[-170],[[26,-166,[5,670,94],[0,0.5,1]],[63,-167],[75,1,2,-168],[43,41,100,150,100,100,-169]],[1,0,-100,0]],[4,"Border",33554432,12,[-173,-174,-175,-176],[[1,-171,[0,"f7NISe7HdAD68SLfhnddy8"],[5,690,265]],[10,1,0,-172,[0,"e71ctEmpxFC4KlSYRZNz/a"],86]],[1,0,150,0]],[57,"EditBox",33554432,[-181,-182],[[[1,-177,[0,"1fhJOVuOVAGYSYZoiE25Uz"],[5,460,90]],-178,[28,45,10,150,10,10,160,40,-179],[113,1,-180]],4,1,4,4],[1,-70,0,0]],[40,"Loading",false,2,[-187,-188],[[[9,-183,[5,750,1334]],[46,-184],[11,45,100,100,-185],-186],4,4,4,1]],[4,"ButtonClose",33554432,7,[-194],[[30,-189,[0,"98TYGMtwRBTYZZn4EZmhzJ"]],[10,1,0,-190,[0,"77BcV1zfNHo4LI4KRqZupe"],103],[19,3,0.9,-192,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"252de94ShdLxLFIQbxXPCxA","Close",7]],[4,4292269782],-191,104,105,106,107],[81,33,25,25,-193]],[1,300,592,0]],[58,"ButtonAgree",33554432,7,[-199],[[[1,-195,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,300,100]],[10,1,0,-196,[0,"77BcV1zfNHo4LI4KRqZupe"],108],-197,[120,20,25,25,130,-198]],4,4,1,4],[1,0,-487,0]],[4,"ButtonClose",33554432,13,[-205],[[30,-200,[0,"98TYGMtwRBTYZZn4EZmhzJ"]],[10,1,0,-201,[0,"77BcV1zfNHo4LI4KRqZupe"],111],[19,3,0.9,-203,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"35d6e3+Q9ZO+4eI42f4ic39","Close",13]],[4,4292269782],-202,112,113,114,115],[81,33,25,25,-204]],[1,300,592,0]],[4,"Close",33554432,4,[-210],[[30,-206,[0,"98TYGMtwRBTYZZn4EZmhzJ"]],[45,3,0.9,-208,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","Exit",3]],[4,4292269782],-207,19],[61,9,25,25,25,100,-209]],[1,-300,500,0]],[4,"Info",33554432,4,[-215],[[30,-211,[0,"98TYGMtwRBTYZZn4EZmhzJ"]],[45,3,0.9,-213,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","Info",3]],[4,4292269782],-212,21],[61,33,25,25,25,100,-214]],[1,300,500,0]],[4,"Users",33554432,1,[-218,-219],[[9,-216,[5,750,110]],[24,41,1170,-217]],[1,0,-1225,0]],[4,"Turns",33554432,32,[-222,-223,-224],[[1,-220,[0,"f7NISe7HdAD68SLfhnddy8"],[5,196,75]],[5,-221,[0,"e71ctEmpxFC4KlSYRZNz/a"],28]],[1,0,-42,0]],[99,"content",33554432,[[1,-225,[0,"99yn0cfL9MmZYfJbPmK9qL"],[5,340,400]],[118,1,1,30,30,30,-226],[28,13,-10,650,91.5,45.5,220,400,-227]],[1,160,-23,0]],[37,"content",33554432,[-231],[[26,-228,[5,670,94],[0,0.5,1]],[75,1,2,-229],[43,41,100,150,100,100,-230]],[1,0,-100,0]],[67,"Container",33554432,[-234,-235,-236],[[1,-232,[0,"3242DVCWtMepBNxixN/wo6"],[5,660,94]],[76,1,1,20,20,-233,[0,"e8diY6Q/dBM44Z0QaBSR6K"]]]],[67,"Container",33554432,[-239,-240,-241],[[1,-237,[0,"3242DVCWtMepBNxixN/wo6"],[5,660,94]],[76,1,1,20,20,-238,[0,"e8diY6Q/dBM44Z0QaBSR6K"]]]],[58,"scrollBar",33554432,20,[-246],[[[3,-242,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,12,1334],[0,1,0.5]],[114,false,1,0,-243,[0,"9dLJe/n0BKVoGauB1wT/Tc"],[4,0],63],[82,37,250,1,-244,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-245],4,4,4,1],[1,375,0,0]],[37,"Back",33554432,[-251],[[30,-247,[0,"98TYGMtwRBTYZZn4EZmhzJ"]],[45,3,0.9,-249,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"abe62Rom6RGOZBhSfqtMLHb","Back",11]],[4,4292269782],-248,67],[61,9,25,25,25,100,-250]],[1,-300,592,0]],[68,"Notification",12,[-253,-254,-255,-256],[[59,-252]],[1,0,750,0]],[100,"Turns",33554432,24,[-259,-260,-261],[[1,-257,[0,"f7NISe7HdAD68SLfhnddy8"],[5,196,75]],[5,-258,[0,"e71ctEmpxFC4KlSYRZNz/a"],84]],[1,88,93,0],[1,0.65,0.65,0.65]],[130,11,[-266,-267,-268,-269,-270,-271],[-262,-263,-264,-265]],[4,"Button",33554432,19,[-276],[[1,-272,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,200,80]],[10,1,0,-273,[0,"77BcV1zfNHo4LI4KRqZupe"],95],[19,3,0.9,-275,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"cd786OL4KtC4rtPw+E8R6+f","Close",19]],[4,4292269782],-274,96,97,98,99]],[1,0,-300,0]],[57,"Toggle",33554432,[-280],[[[1,-277,[0,"a7yxb8GDhNnIT24rnD3lO4"],[5,50,50]],[23,0,-278,[0,"3a4GKzsKZCNLuWHErVRJ1B"],102],-279],4,4,1],[1,25,0,0]],[4,"Facebook",33554432,14,[-285],[[1,-281,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,200,100]],[10,1,0,-282,[0,"77BcV1zfNHo4LI4KRqZupe"],116],[19,3,0.9,-284,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"88819R1zIVFQawyuDuWo1i2","FacebookLogin",14]],[4,4292269782],-283,117,118,119,120]],[1,0,100,0]],[4,"Google",33554432,14,[-290],[[1,-286,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,200,100]],[10,1,0,-287,[0,"77BcV1zfNHo4LI4KRqZupe"],121],[19,3,0.9,-289,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"88819R1zIVFQawyuDuWo1i2","GoogleLogin",14]],[4,4292269782],-288,122,123,124,125]],[1,0,-100,0]],[25,"view",33554432,20,[1],[[1,-291,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,750,1334]],[128,false,-292,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[11,45,240,250,-293]]],[4,"Auction",33554432,4,[-297],[[1,-294,[0,"f7NISe7HdAD68SLfhnddy8"],[5,587,166]],[5,-295,[0,"e71ctEmpxFC4KlSYRZNz/a"],10],[24,1,562,-296]],[1,0,-70,0]],[4,"More",33554432,33,[-301],[[1,-298,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[19,3,0.9,-300,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","Share",3]],[4,4292269782],-299,24,25,26,27]],[1,100,0,0]],[58,"ScrollView",33554432,16,[-305],[[[3,-302,[0,"71kmounFRG/K27WWBbH2RB"],[5,750,537],[0,0,0.5]],-303,[11,45,240,250,-304]],4,1,4],[1,-375,-268.5,0]],[25,"view",33554432,50,[34],[[3,-306,[0,"adVJjE6iNG9YcIKwDKe/zq"],[5,750,537],[0,0,0.5]],[129,-307,[0,"4eIg29oQZFVLk+NZnwDdlk"]],[11,13,750,250,-308]]],[57,"scrollBar",33554432,[-313],[[[3,-309,[0,"17lQPXOPpO0b6Z/3qQRAz3"],[5,12,450],[0,1,0.5]],[10,1,0,-310,[0,"9dLJe/n0BKVoGauB1wT/Tc"],33],[82,37,250,1,-311,[0,"88/VBmjEBOMLWb2cOiN0kU"]],-312],4,4,4,1],[1,750,-725,0]],[25,"view",33554432,9,[35],[[26,-314,[5,670,456],[0,0.5,1]],[63,-315],[44,45,40,40,144,100,100,1,-316]]],[25,"view",33554432,10,[23],[[26,-317,[5,670,456],[0,0.5,1]],[63,-318],[44,45,40,40,144,100,100,1,-319]]],[25,"Top",33554432,11,[-322,39],[[1,-320,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1334]],[42,41,64,-321]]],[4,"Auction",33554432,12,[-326],[[1,-323,[0,"f7NISe7HdAD68SLfhnddy8"],[5,587,166]],[5,-324,[0,"e71ctEmpxFC4KlSYRZNz/a"],73],[24,1,-83,-325]],[1,0,560,0]],[4,"More",33554432,41,[-330],[[1,-327,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[19,3,0.9,-329,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"418ddTz9+lC7bF5livsSJvo","Share",3]],[4,4292269782],-328,80,81,82,83]],[1,100,0,0]],[4,"Bid",33554432,12,[-334],[[1,-331,[0,"98TYGMtwRBTYZZn4EZmhzJ"],[5,150,150]],[19,3,0.9,-333,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[[15,"abe62Rom6RGOZBhSfqtMLHb","Bid",11]],[4,4292269782],-332,88,89,90,91]],[1,258,120,0]],[6,"Overlay",33554432,19,[[1,-335,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1334]],[14,0,-336,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],94],[46,-337],[11,45,20,20,-338]]],[6,"Overlay",33554432,7,[[1,-339,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1334]],[14,0,-340,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],100],[46,-341],[11,45,20,20,-342]]],[68,"ToggleAgree",7,[44,-345],[[9,-343,[5,0,0]],[121,12,50,667,340,-344]],[1,-325,-327,0]],[6,"Overlay",33554432,13,[[1,-346,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1334]],[14,0,-347,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,3355443200],109],[46,-348],[11,45,20,20,-349]]],[131,"main",[-354,-355,2],[132,[[47,["notifications","1"],42,-350,[12,["e71ctEmpxFC4KlSYRZNz/a"]]],[47,["notifications","2"],42,-351,[12,["e71ctEmpxFC4KlSYRZNz/a"]]],[47,["notifications","3"],42,-352,[12,["e71ctEmpxFC4KlSYRZNz/a"]]],[47,["notifications","4"],42,-353,[12,["e71ctEmpxFC4KlSYRZNz/a"]]]]],[133,[134],[135,[4,4283190348]],[136],[137]]],[2,"Background",33554432,4,[[1,-356,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,812]],[5,-357,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[62,1,-358]],[1,0,169,0]],[2,"Coin",33554432,8,[[9,-359,[5,74,71]],[27,-360,1]],[1,-310,380,0]],[2,"Coin-001",33554432,8,[[9,-361,[5,65,71]],[27,-362,2]],[1,-211.715,210.459,0]],[2,"Coin-002",33554432,8,[[9,-363,[5,45,71]],[27,-364,3]],[1,268.825,68.786,0]],[2,"Coin-003",33554432,8,[[9,-365,[5,65,71]],[27,-366,4]],[1,310.945,262.151,0]],[55,"Coin-004",33554432,8,[[9,-367,[5,74,71]],[74,-368,[4,3238002687],5]],[1,234.365,283.21,0],[1,0.75,0.75,0.75]],[55,"Coin-005",33554432,8,[[9,-369,[5,65,71]],[74,-370,[4,3238002687],6]],[1,171.186,472.746,0],[1,0.75,0.75,0.75]],[2,"icon_saleticket",33554432,8,[[9,-371,[5,196,79]],[27,-372,7]],[1,-327.31,138.818,0]],[2,"icon_bid",33554432,8,[[9,-373,[5,124,178]],[27,-374,8]],[1,356.098,93.811,0]],[2,"Logo",33554432,4,[[1,-375,[0,"f7NISe7HdAD68SLfhnddy8"],[5,653,418]],[5,-376,[0,"e71ctEmpxFC4KlSYRZNz/a"],9],[62,1,-377]],[1,0,366,0]],[2,"Label",33554432,15,[[1,-378,[0,"07QMd0h1dLcYd/vjigaip6"],[5,690,96]],[138,"Đấu Giá Ngay",40,1,false,false,true,-379,[0,"ee3IZdy2dLIaAWpjI7P0FL"],13],[83,45,15,100,40,-380]],[1,0,7.5,0]],[108,"Particle",false,33554432,15,[[[59,-381],-382,[150,-383]],4,1,4],[1,0,398,0],[1,30,30,30]],[2,"Bg",33554432,16,[[1,-384,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,537]],[14,0,-385,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4293693733],29],[11,45,40,36,-386]],[1,0,-268.5,0]],[2,"Bg",33554432,16,[[1,-387,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,527]],[14,0,-388,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294354250],30],[43,45,5,5,40,36,-389]],[1,0,-268.5,0]],[4,"Title",33554432,16,[-392],[[1,-390,[0,"f7NISe7HdAD68SLfhnddy8"],[5,638,168]],[5,-391,[0,"e71ctEmpxFC4KlSYRZNz/a"],32]],[1,0,30,0]],[4,"Title",33554432,21,[-395],[[1,-393,[0,"f7NISe7HdAD68SLfhnddy8"],[5,638,168]],[5,-394,[0,"e71ctEmpxFC4KlSYRZNz/a"],37]],[1,0,-10,0]],[6,"Border",33554432,9,[[3,-396,[0,"f7NISe7HdAD68SLfhnddy8"],[5,690,500],[0,0.5,1]],[10,1,0,-397,[0,"e71ctEmpxFC4KlSYRZNz/a"],44],[44,45,30,30,100,690,800,1,-398]]],[4,"Title",33554432,9,[-401],[[1,-399,[0,"f7NISe7HdAD68SLfhnddy8"],[5,638,168]],[5,-400,[0,"e71ctEmpxFC4KlSYRZNz/a"],46]],[1,0,22,0]],[4,"Header",33554432,35,[-403,36],[[1,-402,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,670,94]]],[1,0,-47,0]],[6,"Border",33554432,10,[[3,-404,[0,"f7NISe7HdAD68SLfhnddy8"],[5,690,500],[0,0.5,1]],[10,1,0,-405,[0,"e71ctEmpxFC4KlSYRZNz/a"],53],[44,45,30,30,100,690,800,1,-406]]],[4,"Title",33554432,10,[-409],[[1,-407,[0,"f7NISe7HdAD68SLfhnddy8"],[5,638,168]],[5,-408,[0,"e71ctEmpxFC4KlSYRZNz/a"],55]],[1,0,22,0]],[4,"Header",33554432,23,[-411,37],[[1,-410,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,670,94]]],[1,0,-47,0]],[2,"Time",33554432,37,[[3,-412,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],[64,"Phiên",0,25,25,30,1,false,-413,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380],57],[122,8,20,-414,[0,"76P+K5zndN1ppeFGoea51Q"]]],[1,-310,0,0]],[7,"Bg",33554432,11,[[[3,-415,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1200],[0,0.5,1]],-416,[62,1,-417]],4,1,4],[1,0,667,0]],[55,"Logo",33554432,55,[[1,-418,[0,"f7NISe7HdAD68SLfhnddy8"],[5,653,418]],[5,-419,[0,"e71ctEmpxFC4KlSYRZNz/a"],65],[24,1,50,-420]],[1,0,522.95,0],[1,0.45,0.45,0.45]],[2,"Bg",33554432,12,[[1,-421,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,560]],[10,1,0,-422,[0,"e71ctEmpxFC4KlSYRZNz/a"],72],[11,45,750,189,-423]],[1,0,280,0]],[4,"TextBoxBg",33554432,24,[25],[[1,-424,[0,"f7NISe7HdAD68SLfhnddy8"],[5,620,110]],[10,1,0,-425,[0,"e71ctEmpxFC4KlSYRZNz/a"],85]],[1,0,-32,0]],[6,"Bg",33554432,26,[[1,-426,[0,"f7NISe7HdAD68SLfhnddy8"],[5,750,1334]],[14,0,-427,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,1677721600],92],[11,45,20,20,-428]]],[101,"Icon",33554432,26,[[1,-429,[0,"f7NISe7HdAD68SLfhnddy8"],[5,179,192]],[5,-430,[0,"e71ctEmpxFC4KlSYRZNz/a"],93]],[3,0,0,0.3602706745298867,-0.9328478123862329],[1,0,0,-4722.233639999981]],[2,"WebviewBg",33554432,7,[[1,-431,[0,"f7NISe7HdAD68SLfhnddy8"],[5,650,784]],[14,0,-432,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4291348680],101],[28,45,50,50,150,400,100,100,-433]],[1,0,125,0]],[7,"WebView",33554432,7,[[[1,-434,[0,"a1D+jicHZPDJe8HsX34jia"],[5,650,784]],-435,[28,45,50,50,150,400,100,100,-436]],4,1,4],[1,0,125,0]],[2,"Label",33554432,28,[[1,-437,[0,"07QMd0h1dLcYd/vjigaip6"],[5,300,85]],[139,"Đăng nhập",40,1,false,-438,[0,"ee3IZdy2dLIaAWpjI7P0FL"]],[83,45,15,200,100,-439]],[1,0,7.5,0]],[2,"WebviewBg",33554432,13,[[1,-440,[0,"f7NISe7HdAD68SLfhnddy8"],[5,650,1134]],[14,0,-441,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4291348680],110],[28,45,50,50,150,50,100,100,-442]],[1,0,-50,0]],[7,"WebView",33554432,13,[[[1,-443,[0,"a1D+jicHZPDJe8HsX34jia"],[5,650,1134]],-444,[28,45,50,50,150,50,100,100,-445]],4,1,4],[1,0,-50,0]],[6,"Label",33554432,45,[[1,-446,[0,"07QMd0h1dLcYd/vjigaip6"],[5,200,100]],[32,"Facebook",40,1,false,-447,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]],[11,45,100,40,-448]]],[6,"Label",33554432,46,[[1,-449,[0,"07QMd0h1dLcYd/vjigaip6"],[5,200,100]],[32,"Google",40,1,false,-450,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]],[11,45,100,40,-451]]],[7,"Name",33554432,48,[[[1,-452,[0,"c68UOAlNhN171Umca6yVvF"],[5,420,50]],-453],4,1],[1,0,-41,0]],[6,"Bg",33554432,5,[[1,-454,[0,"f7NISe7HdAD68SLfhnddy8"],[5,548,119]],[5,-455,[0,"e71ctEmpxFC4KlSYRZNz/a"],11]]],[7,"H1",33554432,5,[[[1,-456,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-457],4,1],[1,-236,0,0]],[7,"H2",33554432,5,[[[1,-458,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-459],4,1],[1,-150,0,0]],[7,"M1",33554432,5,[[[1,-460,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-461],4,1],[1,-43,0,0]],[7,"M2",33554432,5,[[[1,-462,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-463],4,1],[1,43,0,0]],[7,"S1",33554432,5,[[[1,-464,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-465],4,1],[1,150,0,0]],[7,"S2",33554432,5,[[[1,-466,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-467],4,1],[1,236,0,0]],[2,"Fg",33554432,5,[[1,-468,[0,"f7NISe7HdAD68SLfhnddy8"],[5,556,173]],[5,-469,[0,"e71ctEmpxFC4KlSYRZNz/a"],12]],[1,0,-23,0]],[6,"Icon",33554432,30,[[1,-470,[0,"f7NISe7HdAD68SLfhnddy8"],[5,71,78]],[5,-471,[0,"e71ctEmpxFC4KlSYRZNz/a"],18]]],[6,"Icon",33554432,31,[[1,-472,[0,"f7NISe7HdAD68SLfhnddy8"],[5,107,118]],[5,-473,[0,"e71ctEmpxFC4KlSYRZNz/a"],20]]],[7,"Name",33554432,32,[[[1,-474,[0,"c68UOAlNhN171Umca6yVvF"],[5,750,100]],-475],4,1],[1,0,42.328,0]],[2,"Coin",33554432,33,[[1,-476,[0,"f7NISe7HdAD68SLfhnddy8"],[5,90,90]],[23,0,-477,[0,"e71ctEmpxFC4KlSYRZNz/a"],22]],[1,-90,0,0]],[7,"Turn",33554432,33,[[[1,-478,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,50]],-479],4,1],[1,10,2,0]],[6,"Icon",33554432,49,[[1,-480,[0,"f7NISe7HdAD68SLfhnddy8"],[5,62,66]],[5,-481,[0,"e71ctEmpxFC4KlSYRZNz/a"],23]]],[69,"Spacing",1,[[26,-482,[5,750,100],[0,0.5,1]],[31,41,1300,100,-483]],[1,0,-1300,0]],[2,"Label",33554432,78,[[1,-484,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,50.4]],[48,"DANH SÁCH ĐẤU GIÁ",28,28,1,false,true,-485,[0,"2frm37uaJHQr0AEEaYyM82"],31]],[1,0,-39,0]],[7,"bar",33554432,52,[[[3,-486,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,10,156.25],[0,0,0]],-487],4,1],[1,-11,-31.25,0]],[69,"Spacing",1,[[26,-488,[5,750,46],[0,0.5,1]],[31,41,1977,100,-489]],[1,0,-1977,0]],[2,"Border",33554432,21,[[3,-490,[0,"f7NISe7HdAD68SLfhnddy8"],[5,690,680],[0,0.5,1]],[10,1,0,-491,[0,"e71ctEmpxFC4KlSYRZNz/a"],35]],[1,0,-30,0]],[2,"Label",33554432,79,[[1,-492,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,50.4]],[48,"CÁCH THAM GIA",28,28,1,false,true,-493,[0,"2frm37uaJHQr0AEEaYyM82"],36]],[1,0,-39,0]],[2,"Login",33554432,22,[[1,-494,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,200]],[49,"Đăng nhập phiên\nđấu giá",29.999,29.999,35,1,false,-495,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],38]],[1,-155,-180,0]],[2,"Gift",33554432,22,[[1,-496,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,200]],[49,"Nhận quà ngẫu\nnhiên trước mỗi\nphiên đấu giá",29.999,29.999,35,1,false,-497,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],39]],[1,155,-200,0]],[2,"Turns",33554432,22,[[1,-498,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,200]],[49,"Đấu giá và mời\nbạn bè để có\nthêm lượt",29.999,29.999,35,1,false,-499,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],40]],[1,-155,-475,0]],[2,"Result",33554432,22,[[1,-500,[0,"c68UOAlNhN171Umca6yVvF"],[5,300,200]],[49,"Theo dõi kết quả\nvào cuối phiên\nđấu giá",29.999,29.999,35,1,false,-501,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281874488],41]],[1,155,-475,0]],[2,"Label",33554432,81,[[1,-502,[0,"c68UOAlNhN171Umca6yVvF"],[5,400,50.4]],[48,"LỊCH SỬ ĐẤU GIÁ",28,28,1,false,true,-503,[0,"2frm37uaJHQr0AEEaYyM82"],45]],[1,0,-39,0]],[6,"Bg",33554432,82,[[1,-504,[0,"f7NISe7HdAD68SLfhnddy8"],[5,670,94]],[14,0,-505,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294965740],47]]],[2,"Time",33554432,36,[[3,-506,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],[140,"Phiên",0,28,28,1,false,-507,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380],48]],[1,-310,0,0]],[2,"Description",33554432,36,[[3,-508,[0,"c68UOAlNhN171Umca6yVvF"],[5,340,94],[0,0,0.5]],[87,"Khách Sạn",0,28,28,1,false,true,-509,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380],49]],[1,-170,0,0]],[2,"Status",33554432,36,[[3,-510,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],[87,"Giá Đấu",0,28,28,1,false,true,-511,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380],50]],[1,170,0,0]],[6,"Sprite",33554432,17,[[1,-512,[0,"f7NISe7HdAD68SLfhnddy8"],[5,80,80]],[23,0,-513,[0,"e71ctEmpxFC4KlSYRZNz/a"],51]]],[2,"Label",33554432,84,[[1,-514,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,50.4]],[48,"DANH SÁCH NGƯỜI TRÚNG THƯỞNG",28,28,1,false,true,-515,[0,"2frm37uaJHQr0AEEaYyM82"],54]],[1,0,-39,0]],[6,"Bg",33554432,85,[[1,-516,[0,"f7NISe7HdAD68SLfhnddy8"],[5,670,94]],[14,0,-517,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4294831615],56]]],[2,"Winner",33554432,37,[[3,-518,[0,"c68UOAlNhN171Umca6yVvF"],[5,340,94],[0,0,0.5]],[64,"Khách Hàng",0,25,25,30,1,false,-519,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380],58]],[1,-170,0,0]],[2,"Price",33554432,37,[[3,-520,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],[64,"Giá Đấu",0,25,25,30,1,false,-521,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380],59]],[1,170,0,0]],[6,"Sprite",33554432,18,[[1,-522,[0,"f7NISe7HdAD68SLfhnddy8"],[5,80,80]],[23,0,-523,[0,"e71ctEmpxFC4KlSYRZNz/a"],60]]],[7,"bar",33554432,38,[[[3,-524,[0,"95oWyE8aJJxJ5UvVmOXyZU"],[5,10,558.9057788944724],[0,0,0]],-525],4,1],[1,-11,108.0942211055276,0]],[6,"Icon",33554432,39,[[1,-526,[0,"f7NISe7HdAD68SLfhnddy8"],[5,71,78]],[5,-527,[0,"e71ctEmpxFC4KlSYRZNz/a"],66]]],[38,40,[20,"7aFiDHn+NClKHPLQ2dj3zj",-531,[21,"326+nkc0hO36x0TSXjkFcL",[[22,"ItemNotification",["name"],-528],[13,["position"],-529,[1,0,120,0]],[13,["rotation"],-530,[3,0,0,0,1]],[50,["position"],[12,["84yO6BiwFDMrUdCMsCSdJv"]],[1,30,-7.5,0]]]],68]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[38,40,[20,"7aFiDHn+NClKHPLQ2dj3zj",-535,[21,"69Qvi4tOZGkZcPQ4lkWdQ1",[[22,"ItemNotification",["name"],-532],[13,["position"],-533,[1,0,80,0]],[13,["rotation"],-534,[3,0,0,0,1]],[50,["position"],[12,["84yO6BiwFDMrUdCMsCSdJv"]],[1,30,-7.5,0]]]],69]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[38,40,[20,"7aFiDHn+NClKHPLQ2dj3zj",-539,[21,"d4nlBWj2hLWK7bsk3BLsoA",[[22,"ItemNotification",["name"],-536],[13,["position"],-537,[1,0,40,0]],[13,["rotation"],-538,[3,0,0,0,1]],[50,["position"],[12,["84yO6BiwFDMrUdCMsCSdJv"]],[1,30,-7.5,0]]]],70]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[38,40,[20,"7aFiDHn+NClKHPLQ2dj3zj",-543,[21,"71mBAiiERGEb8A2EprXYvV",[[22,"ItemNotification",["name"],-540],[13,["position"],-541,[1,0,0,0]],[13,["rotation"],-542,[3,0,0,0,1]],[50,["position"],[12,["84yO6BiwFDMrUdCMsCSdJv"]],[1,30,-7.5,0]]]],71]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[7,"Name",33554432,56,[[[1,-544,[0,"c68UOAlNhN171Umca6yVvF"],[5,420,50]],-545],4,1],[1,0,-38,0]],[6,"Bg",33554432,6,[[1,-546,[0,"f7NISe7HdAD68SLfhnddy8"],[5,548,119]],[5,-547,[0,"e71ctEmpxFC4KlSYRZNz/a"],74]]],[7,"H1",33554432,6,[[[1,-548,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-549],4,1],[1,-236,0,0]],[7,"H2",33554432,6,[[[1,-550,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-551],4,1],[1,-150,0,0]],[7,"M1",33554432,6,[[[1,-552,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-553],4,1],[1,-43,0,0]],[7,"M2",33554432,6,[[[1,-554,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-555],4,1],[1,43,0,0]],[7,"S1",33554432,6,[[[1,-556,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-557],4,1],[1,150,0,0]],[7,"S2",33554432,6,[[[1,-558,[0,"c68UOAlNhN171Umca6yVvF"],[5,74,120]],-559],4,1],[1,236,0,0]],[2,"Fg",33554432,6,[[1,-560,[0,"f7NISe7HdAD68SLfhnddy8"],[5,556,173]],[5,-561,[0,"e71ctEmpxFC4KlSYRZNz/a"],75]],[1,0,-23,0]],[2,"Turn",33554432,24,[[1,-562,[0,"c68UOAlNhN171Umca6yVvF"],[5,195.93,50.4]],[141,"Lượt của bạn:",0,30,30,false,true,-563,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286594573],76]],[1,-130,95,0]],[2,"Hint",33554432,24,[[1,-564,[0,"c68UOAlNhN171Umca6yVvF"],[5,343.68391403549725,50.4]],[142,"Bước giá (đặt làm tròn): 100đ",0,25,25,false,true,-565,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286594573],77]],[1,-140,45,0]],[2,"Coin",33554432,41,[[1,-566,[0,"f7NISe7HdAD68SLfhnddy8"],[5,90,90]],[23,0,-567,[0,"e71ctEmpxFC4KlSYRZNz/a"],78]],[1,-90,0,0]],[7,"Turn",33554432,41,[[[1,-568,[0,"c68UOAlNhN171Umca6yVvF"],[5,100,50]],-569],4,1],[1,10,2,0]],[6,"Icon",33554432,57,[[1,-570,[0,"f7NISe7HdAD68SLfhnddy8"],[5,62,66]],[5,-571,[0,"e71ctEmpxFC4KlSYRZNz/a"],79]]],[109,"TEXT_LABEL",false,33554432,25,[[[3,-572,[0,"779kAXGTtMZKXfYlOg0Tfd"],[5,458,90],[0,0,1]],-573],4,1],[1,-228,45,0]],[7,"PLACEHOLDER_LABEL",33554432,25,[[[3,-574,[0,"d07wQj4whCUqYGJH1lEpVp"],[5,458,90],[0,0,1]],-575],4,1],[1,-228,45,0]],[6,"Icon",33554432,58,[[1,-576,[0,"f7NISe7HdAD68SLfhnddy8"],[5,94,100]],[5,-577,[0,"e71ctEmpxFC4KlSYRZNz/a"],87]]],[110,"Message",33554432,19,[[[1,-578,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,500]],-579],4,1]],[6,"Label",33554432,43,[[1,-580,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[32,"Close",40,1,false,-581,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]]]],[111,"Checkmark",false,33554432,44,[[[1,-582,[0,"e4k6OSwohL75lyfsntvPC5"],[5,26,26]],-583],4,1]],[2,"Label",33554432,61,[[3,-584,[0,"c68UOAlNhN171Umca6yVvF"],[5,600,50.4],[0,0,0.5]],[143,"Tôi đã đọc và đồng ý",0,30,30,1,-585,[0,"2frm37uaJHQr0AEEaYyM82"]]],[1,60,0,0]],[6,"Label",33554432,27,[[1,-586,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[32,"X",40,1,false,-587,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]]]],[6,"Label",33554432,29,[[1,-588,[0,"07QMd0h1dLcYd/vjigaip6"],[5,100,40]],[32,"X",40,1,false,-589,[0,"ee3IZdy2dLIaAWpjI7P0FL"],[4,4278190080]]]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[12,["7aFiDHn+NClKHPLQ2dj3zj"]],[102,"Main Camera","c9DMICJLFO5IeO07EPon7U",63,[[151,1822425087,-590]],[1,-10,10,10],[3,-0.27781593346944056,-0.36497167621709875,-0.11507512748638377,0.8811195706053617],[1,-35,-45,0]],[103,"GameMgr","cfnugoLNRBn4krmo0no0Tq",63,[[153,-597,-596,-595,42,-594,-593,-592,-591]]],[154,14],[112,"Camera",2,[-598],[1,0,0,1000]],[152,0,1073741824,667,2000,6,41943040,176,[4,4278190080]],[88,"KHÁCH SẠN MƯỜNG THANH",30,30,2,false,100,[0,"2frm37uaJHQr0AEEaYyM82"]],[17,"2",101,100,2,false,true,102,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,103,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,104,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,105,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,106,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,107,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[155,true,200,75,[0,"0b7a7v3FVOCpzmec7amMlB"],[[14,null],6,0],[51],[29,3,0.05,2],[16],[16],[29,3,30,50],[33,3,6.283185307179586],[33,3,6.283185307179586],[33,3,6.283185307179586],[16],[29,3,1.5,2.2],[16],[16],[16],[[159,0.01,[52,200]]],[160,[51]],[161,true,3,2,0.01,[52,1]],[162,true,[156,1,[34,2,8,[[35,1],[93,0.82,1],[163,1,-3.17]]]],[16],[16],[16]],[166,[16],[16],[16],[52,1]],[167,[29,3,0.3,-0.3],[29,3,0.3,-0.3],[29,3,0.3,-0.3]],[168,true,0.99,[91,1,100,[34,2,8,[[35,1],[36,0.2],[36,1]]]],[92,100],[92,100],[91,1,100,[34,2,8,[[35,1],[36,0.2],[36,1]]]]],[169,true,[33,3,6.283185307179586],[157,3],[158,2,18.84955592153876,[34,2,8,[[35,0.01],[36,1]]],[34,2,8,[[35,1],[93,0.15,1],[164,0.2,0.5,-0.23,-0.23],[165,1,0.3,-0.14]]]]],[170,true,3,3,1,true,[33,3,8],[16]],[171,[52,1],[16],[51],[51],-599],[172,15]],[144,"Nguyễn Văn A",40,1,false,true,111,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281546037]],[89,"2",38,38,1,false,true,113,[0,"2frm37uaJHQr0AEEaYyM82"]],[173,0.23,0.75,false,50,[0,"a8UaPDxYhIX5MrqvKGMJdR"],34],[175,1,52,[0,"f4i77UV0dH4pcD0KQOXx7c"],188],[60,1,0,117,[0,"02Vchn8fFF/77B+7pVCQuQ"]],[115,1,0,136,[0,"02Vchn8fFF/77B+7pVCQuQ"],[4,6579300]],[176,1,true,38,[0,"f4i77UV0dH4pcD0KQOXx7c"],191],[174,0.23,false,false,20,[0,"a8UaPDxYhIX5MrqvKGMJdR"],1,192],[177,3,178,32,186,187,9,35,17,10,23,18,34,[179,180,181,182,183,184],[65,66,67,68,69,70,71,72]],[116,0,87,[0,"e71ctEmpxFC4KlSYRZNz/a"],[4,4288059030]],[88,"KHÁCH SẠN MƯỜNG THANH",25,25,2,false,146,[0,"2frm37uaJHQr0AEEaYyM82"]],[17,"2",101,100,2,false,true,148,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,149,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,150,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,151,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,152,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[17,"2",101,100,2,false,true,153,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4286845695]],[89,"2",38,38,1,false,true,158,[0,"2frm37uaJHQr0AEEaYyM82"]],[90,"",0,20,50,1,false,false,160,[0,"ddIY+NJvlDTIQAg7PLVrGo"]],[145,"Nhập giá ở đây",0,40,90,1,false,false,161,[0,"8fhi7qRLFJbK0abIJuXmCW"],[4,4290032820]],[178,2,8,25,[0,"1bCHrwPGZOPrbmPh93kwpe"],204,205],[179,26,92],[146,"",40,1,163,[0,"2frm37uaJHQr0AEEaYyM82"]],[180,19,208],[94,"https://mytour.vn",94,[0,"abdA5skhVLkY1+gRdDYTFK"]],[41,0,165,[0,"25nHiyhlVLhbUiFI4JJ9Sn"]],[181,false,44,[0,"58GFHdMmJFBa4quSrrbzsk"],[4,4292269782],44,211],[127,3,0.9,28,[0,"2fOwBXUwBNvaJ4NyyrOq4C"],[4,4292269782],28],[182,7,210,212,213],[94,"https://mytour.vn",97,[0,"abdA5skhVLkY1+gRdDYTFK"]],[183,13,215],[39,[20,"7aFiDHn+NClKHPLQ2dj3zj",-600,[21,"ddQJ/0upNCGIlyUUWcERv4",[[22,"ItemNotification",["name"],169],[13,["position"],169,[1,0,200,0]],[13,["rotation"],169,[3,0,0,0,1]]]],126]],[39,[20,"7aFiDHn+NClKHPLQ2dj3zj",-601,[21,"37t1CQKxNJL6br5zD6kmG4",[[22,"ItemNotification",["name"],170],[13,["position"],170,[1,0,0,0]],[13,["rotation"],170,[3,0,0,0,1]]]],127]],[39,[20,"7aFiDHn+NClKHPLQ2dj3zj",-602,[21,"99ZMLgGHhGbKjvsXnfkBEE",[[22,"ItemNotification",["name"],171],[13,["position"],171,[1,0,-100,0]],[13,["rotation"],171,[3,0,0,0,1]]]],128]],[39,[20,"7aFiDHn+NClKHPLQ2dj3zj",-603,[21,"b1SLo7N61Of589yzmDLAqH",[[22,"ItemNotification",["name"],172],[13,["position"],172,[1,0,-200,0]],[13,["rotation"],172,[3,0,0,0,1]]]],129]]],0,[0,0,1,0,0,1,0,0,1,0,0,1,0,-1,4,0,-2,32,0,-3,115,0,-4,16,0,-5,118,0,-6,21,0,-7,9,0,-8,10,0,0,2,0,20,177,0,0,2,0,0,2,0,-1,176,0,-2,14,0,-3,3,0,-4,11,0,-5,26,0,-6,19,0,-7,7,0,-8,13,0,0,3,0,-2,194,0,0,3,0,-1,20,0,0,4,0,0,4,0,-1,64,0,-2,8,0,-3,73,0,-4,48,0,-5,5,0,-6,15,0,-7,30,0,-8,31,0,0,5,0,0,5,0,-1,101,0,-2,102,0,-3,103,0,-4,104,0,-5,105,0,-6,106,0,-7,107,0,-8,108,0,0,6,0,0,6,0,-1,147,0,-2,148,0,-3,149,0,-4,150,0,-5,151,0,-6,152,0,-7,153,0,-8,154,0,0,7,0,0,7,0,-3,214,0,-1,60,0,-2,93,0,-3,94,0,-4,61,0,-5,27,0,-6,28,0,0,8,0,-1,65,0,-2,66,0,-3,67,0,-4,68,0,-5,69,0,-6,70,0,-7,71,0,-8,72,0,0,9,0,0,9,0,0,9,0,-1,80,0,-2,81,0,-3,53,0,-4,17,0,0,10,0,0,10,0,0,10,0,-1,83,0,-2,84,0,-3,54,0,-4,18,0,0,11,0,0,11,0,-3,42,0,-1,87,0,-2,55,0,-3,12,0,0,12,0,0,12,0,-1,40,0,-2,89,0,-3,56,0,-5,24,0,-6,58,0,0,13,0,0,13,0,-3,216,0,-1,62,0,-2,96,0,-3,97,0,-4,29,0,0,14,0,-2,175,0,0,14,0,-1,45,0,-2,46,0,0,15,0,0,15,0,4,15,0,0,15,0,0,15,0,-1,74,0,-2,75,0,0,16,0,0,16,0,0,16,0,-1,76,0,-2,77,0,-3,78,0,-4,50,0,0,17,0,0,17,0,4,17,0,0,17,0,0,17,0,-1,130,0,0,18,0,0,18,0,4,18,0,0,18,0,0,18,0,-1,135,0,0,19,0,0,19,0,-3,209,0,-1,59,0,-2,163,0,-3,43,0,0,20,0,0,20,0,-3,193,0,0,20,0,-1,47,0,-2,38,0,0,21,0,0,21,0,0,21,0,-1,119,0,-2,79,0,-3,22,0,0,22,0,0,22,0,-1,121,0,-2,122,0,-3,123,0,-4,124,0,0,23,0,0,23,0,0,23,0,0,23,0,-1,85,0,0,24,0,0,24,0,-1,155,0,-2,156,0,-3,41,0,-4,90,0,0,25,0,-2,206,0,0,25,0,0,25,0,-1,160,0,-2,161,0,0,26,0,0,26,0,0,26,0,-4,207,0,-1,91,0,-2,92,0,0,27,0,0,27,0,4,27,0,0,27,0,0,27,0,-1,167,0,0,28,0,0,28,0,-3,213,0,0,28,0,-1,95,0,0,29,0,0,29,0,4,29,0,0,29,0,0,29,0,-1,168,0,0,30,0,4,30,0,0,30,0,0,30,0,-1,109,0,0,31,0,4,31,0,0,31,0,0,31,0,-1,110,0,0,32,0,0,32,0,-1,111,0,-2,33,0,0,33,0,0,33,0,-1,112,0,-2,113,0,-3,49,0,0,34,0,0,34,0,0,34,0,0,35,0,0,35,0,0,35,0,-1,82,0,0,36,0,0,36,0,-1,127,0,-2,128,0,-3,129,0,0,37,0,0,37,0,-1,86,0,-2,133,0,-3,134,0,0,38,0,0,38,0,0,38,0,-4,192,0,-1,136,0,0,39,0,4,39,0,0,39,0,0,39,0,-1,137,0,0,40,0,-1,138,0,-2,140,0,-3,142,0,-4,144,0,0,41,0,0,41,0,-1,157,0,-2,158,0,-3,57,0,-1,138,0,-2,140,0,-3,142,0,-4,144,0,-1,197,0,-2,198,0,-3,199,0,-4,200,0,-5,201,0,-6,202,0,0,43,0,0,43,0,4,43,0,0,43,0,-1,164,0,0,44,0,0,44,0,-3,212,0,-1,165,0,0,45,0,0,45,0,4,45,0,0,45,0,-1,98,0,0,46,0,0,46,0,4,46,0,0,46,0,-1,99,0,0,47,0,0,47,0,0,47,0,0,48,0,0,48,0,0,48,0,-1,100,0,0,49,0,4,49,0,0,49,0,-1,114,0,0,50,0,-2,188,0,0,50,0,-1,51,0,0,51,0,0,51,0,0,51,0,0,52,0,0,52,0,0,52,0,-4,189,0,-1,117,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,-1,88,0,0,56,0,0,56,0,0,56,0,-1,146,0,0,57,0,4,57,0,0,57,0,-1,159,0,0,58,0,4,58,0,0,58,0,-1,162,0,0,59,0,0,59,0,0,59,0,0,59,0,0,60,0,0,60,0,0,60,0,0,60,0,0,61,0,0,61,0,-2,166,0,0,62,0,0,62,0,0,62,0,0,62,0,13,217,0,13,218,0,13,219,0,13,220,0,-1,173,0,-2,174,0,0,64,0,0,64,0,0,64,0,0,65,0,0,65,0,0,66,0,0,66,0,0,67,0,0,67,0,0,68,0,0,68,0,0,69,0,0,69,0,0,70,0,0,70,0,0,71,0,0,71,0,0,72,0,0,72,0,0,73,0,0,73,0,0,73,0,0,74,0,0,74,0,0,74,0,0,75,0,-2,185,0,0,75,0,0,76,0,0,76,0,0,76,0,0,77,0,0,77,0,0,77,0,0,78,0,0,78,0,-1,116,0,0,79,0,0,79,0,-1,120,0,0,80,0,0,80,0,0,80,0,0,81,0,0,81,0,-1,125,0,0,82,0,-1,126,0,0,83,0,0,83,0,0,83,0,0,84,0,0,84,0,-1,131,0,0,85,0,-1,132,0,0,86,0,0,86,0,0,86,0,0,87,0,-2,195,0,0,87,0,0,88,0,0,88,0,0,88,0,0,89,0,0,89,0,0,89,0,0,90,0,0,90,0,0,91,0,0,91,0,0,91,0,0,92,0,0,92,0,0,93,0,0,93,0,0,93,0,0,94,0,-2,210,0,0,94,0,0,95,0,0,95,0,0,95,0,0,96,0,0,96,0,0,96,0,0,97,0,-2,215,0,0,97,0,0,98,0,0,98,0,0,98,0,0,99,0,0,99,0,0,99,0,0,100,0,-2,178,0,0,101,0,0,101,0,0,102,0,-2,179,0,0,103,0,-2,180,0,0,104,0,-2,181,0,0,105,0,-2,182,0,0,106,0,-2,183,0,0,107,0,-2,184,0,0,108,0,0,108,0,0,109,0,0,109,0,0,110,0,0,110,0,0,111,0,-2,186,0,0,112,0,0,112,0,0,113,0,-2,187,0,0,114,0,0,114,0,0,115,0,0,115,0,0,116,0,0,116,0,0,117,0,-2,190,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,121,0,0,121,0,0,122,0,0,122,0,0,123,0,0,123,0,0,124,0,0,124,0,0,125,0,0,125,0,0,126,0,0,126,0,0,127,0,0,127,0,0,128,0,0,128,0,0,129,0,0,129,0,0,130,0,0,130,0,0,131,0,0,131,0,0,132,0,0,132,0,0,133,0,0,133,0,0,134,0,0,134,0,0,135,0,0,135,0,0,136,0,-2,191,0,0,137,0,0,137,0,6,139,0,6,139,0,6,139,0,7,138,0,6,141,0,6,141,0,6,141,0,7,140,0,6,143,0,6,143,0,6,143,0,7,142,0,6,145,0,6,145,0,6,145,0,7,144,0,0,146,0,-2,196,0,0,147,0,0,147,0,0,148,0,-2,197,0,0,149,0,-2,198,0,0,150,0,-2,199,0,0,151,0,-2,200,0,0,152,0,-2,201,0,0,153,0,-2,202,0,0,154,0,0,154,0,0,155,0,0,155,0,0,156,0,0,156,0,0,157,0,0,157,0,0,158,0,-2,203,0,0,159,0,0,159,0,0,160,0,-2,204,0,0,161,0,-2,205,0,0,162,0,0,162,0,0,163,0,-2,208,0,0,164,0,0,164,0,0,165,0,-2,211,0,0,166,0,0,166,0,0,167,0,0,167,0,0,168,0,0,168,0,0,173,0,21,216,0,22,214,0,23,209,0,24,207,0,25,194,0,26,175,0,0,174,0,-1,177,0,27,185,0,7,217,0,7,218,0,7,219,0,7,220,0,28,63,1,8,47,2,8,63,6,8,12,23,8,54,25,8,90,34,8,51,35,8,53,36,8,82,37,8,85,39,8,55,42,29,206,42,30,203,42,31,196,42,32,195,44,8,61,188,33,189,189,34,190,192,35,193,603],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,179,180,181,182,183,184,186,187,190,191,194,194,194,195,197,198,199,200,201,202,203,204,205,211,212,213],[1,1,1,1,1,1,1,1,1,1,1,1,1,2,-1,36,1,5,1,5,1,5,1,1,5,9,10,11,1,1,1,2,1,1,1,1,2,1,2,2,2,2,1,1,1,2,1,1,2,2,2,1,1,1,2,1,1,2,2,2,1,1,1,1,1,1,1,5,12,12,12,12,1,1,1,1,2,2,1,1,5,9,10,11,1,1,1,1,5,9,10,11,1,1,1,1,5,9,10,11,1,1,1,1,5,9,10,11,1,1,1,1,5,9,10,11,1,5,9,10,11,1,5,9,10,11,12,12,12,12,2,2,2,2,2,2,2,2,1,1,37,38,39,1,2,2,2,2,2,2,2,2,2,1,5,5],[32,9,33,34,13,9,13,35,36,14,15,16,17,3,37,12,10,10,18,1,38,1,9,19,2,2,6,7,20,1,1,3,11,39,1,21,3,11,3,3,3,3,40,1,22,3,11,1,3,5,5,23,1,22,3,11,1,3,3,3,23,1,1,24,41,14,18,1,8,8,8,8,42,15,16,17,3,3,9,19,2,2,6,7,20,43,21,44,2,2,6,7,1,45,1,2,2,2,6,7,1,1,25,2,2,2,6,7,10,1,1,2,2,2,6,7,2,2,2,6,7,2,2,2,6,7,8,8,8,8,4,4,4,4,4,4,3,3,46,24,47,48,49,1,4,4,4,4,4,4,3,3,3,50,25,10]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["afxHkx8GZGsJC+n+YfITQo"]}],[7],0,[],[],[]],[[{"name":"default_scrollbar_vertical","rect":{"x":0,"y":0,"width":15,"height":30},"offset":{"x":0,"y":0},"originalSize":{"width":15,"height":30},"rotated":false,"capInsets":[4,10,4,10],"texture":"afc47931-f066-46b0-90be-9fe61f213428@6c48a","packable":true}],[0],0,[0],[3],[51]],[[{"name":"button_thele","rect":{"x":1107,"y":663,"width":107,"height":118},"offset":{"x":0,"y":0},"originalSize":{"width":107,"height":118},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["b7MFJ8MjNBwqr3fNq1j5dJ"]}],[7],0,[],[],[]],[[{"name":"default_panel","rect":{"x":0,"y":0,"width":20,"height":20},"offset":{"x":0,"y":0},"originalSize":{"width":20,"height":20},"rotated":false,"capInsets":[8,8,8,8],"texture":"b730527c-3233-41c2-aaf7-7cdab58f9749@6c48a","packable":true}],[0],0,[0],[3],[52]],[[{"name":"mainscreen_top_artbg","rect":{"x":3,"y":3,"width":750,"height":812},"offset":{"x":0,"y":0},"originalSize":{"width":750,"height":812},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"COIN_3","rect":{"x":1154,"y":1818,"width":65,"height":71},"offset":{"x":0,"y":1},"originalSize":{"width":75,"height":75},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[53,"ItemBidding"],[56,"ItemBidding",33554432,[-8,-9],[[1,-2,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,670,94]],[184,-7,[0,"235Eo9J4FNQJ+uv+k607Ff"],-6,-5,-4,-3]],[8,"80oVypFg9Ea5rK9ZuAfYlh",-1,0],[1,0,-141,0]],[70,"Container",33554432,1,[-12,-13,-14],[[1,-10,[0,"3242DVCWtMepBNxixN/wo6"],[5,620,94]],[77,1,1,-11,[0,"e8diY6Q/dBM44Z0QaBSR6K"]]],[8,"2cAB3vm0dMyI7ZFgt7HE8v",1,0]],[73,"Bg",33554432,1,[[[1,-15,[0,"f7NISe7HdAD68SLfhnddy8"],[5,670,94]],-16],4,1],[8,"a8OMyFqFRGBqO1fu7Q0rmJ",1,0]],[18,"Time",33554432,2,[[[3,-17,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],-18],4,1],[8,"138ACOBEhDCJHTetcW3C00",1,0],[1,-310,0,0]],[18,"Description",33554432,2,[[[3,-19,[0,"c68UOAlNhN171Umca6yVvF"],[5,340,94],[0,0,0.5]],-20],4,1],[8,"8aK+R4pM9M2YIhahqJqu60",1,0],[1,-170,0,0]],[18,"Price",33554432,2,[[[3,-21,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],-22],4,1],[8,"4e/TVRUaZFHJwrL1PpdXPr",1,0],[1,170,0,0]],[41,0,3,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[65,"02/07\n16:59",0,25,25,30,1,false,4,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380]],[65,"Khách sạn Mường Thanh",0,25,25,30,1,false,5,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380]],[65,"2",0,25,25,30,1,false,6,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380]]],0,[0,7,1,0,0,1,0,16,10,0,40,9,0,15,8,0,17,7,0,0,1,0,-1,3,0,-2,2,0,0,2,0,0,2,0,-1,4,0,-2,5,0,-3,6,0,0,3,0,-2,7,0,0,4,0,-2,8,0,0,5,0,-2,9,0,0,6,0,-2,10,0,14,1,22],[7,8,9,10],[1,2,2,2],[1,5,5,5]],[[[53,"ItemProgram"],[56,"ItemProgram",33554432,[-10,-11,-12,-13,-14,-15,-16],[[3,-2,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,280,423],[0,0,0.5]],[185,-9,[0,"51OKZ7LeJEBajmFB/+z0cu"],-8,-7,-6,-5,-4,-3]],[8,"80oVypFg9Ea5rK9ZuAfYlh",-1,0],[1,-140,0,0]],[71,"BgPink",33554432,1,[[1,-17,[0,"f7NISe7HdAD68SLfhnddy8"],[5,280,423]],[23,0,-18,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[84,45,64,64,-19,[0,"475I1t28ZJRp7JB9Em+HjG"]]],[8,"a8OMyFqFRGBqO1fu7Q0rmJ",1,0],[1,140,0,0]],[104,"BgBlue",false,33554432,1,[[1,-20,[0,"ebAmohRdtFr6LFE1iCqU5z"],[5,280,423]],[23,0,-21,[0,"81ocjVG/xGEJnDH744VCpT"],1],[84,45,64,64,-22,[0,"99yOFCPGFHIY4+xSoSDaob"]]],[8,"64PpGsFc9DWZp2i5qS+d3k",1,0],[1,140,0,0]],[18,"Time",33554432,1,[[[1,-23,[0,"c68UOAlNhN171Umca6yVvF"],[5,160,50]],-24,[123,9,16.5,118.87,20,186.3,42.26,50.4,-25,[0,"e34O/+IHxJm6li7VdWBwqK"]]],4,1,4],[8,"6bD1iWtCVGXJQ5tiKLvUpH",1,0],[1,96.5,166.5,0]],[18,"Hotel",33554432,1,[[[3,-26,[0,"c68UOAlNhN171Umca6yVvF"],[5,164,50],[0,0.5,0]],-27,[85,44,16,100,50,42.26,-28,[0,"d10mHO55JPdqwIypdsesmX"]]],4,1,4],[8,"98t4J/MY1JPa115NySkeQy",1,0],[1,98,-161.5,0]],[18,"Location",33554432,1,[[[1,-29,[0,"4cYSUTjKJLX7SvvC7KocKH"],[5,164,30]],-30,[85,44,16,100,24,42.26,-31,[0,"8e1cKMCcZIP7xkIq0yuOLO"]]],4,1,4],[8,"b0QHne1CJBDLBOxR/um8qo",1,0],[1,98,-172.5,0]],[71,"Border",33554432,1,[[1,-32,[0,"f7NISe7HdAD68SLfhnddy8"],[5,82,82]],[5,-33,[0,"e71ctEmpxFC4KlSYRZNz/a"],2],[124,36,15,26,-34,[0,"6d/RyAtJlKdpug5bqBhGQ/"]]],[8,"eaWUhgc85AkqE4sYjRAwMD",1,0],[1,224,-144.5,0]],[18,"Thumnail",33554432,1,[[[1,-35,[0,"f7NISe7HdAD68SLfhnddy8"],[5,80,80]],-36],4,1],[8,"79MBrQ6rpPX6hm7CO+Fvo9",1,0],[1,224,-144.5,0]],[147,"09:00 - 05/05",20,20,1,false,4,[0,"2frm37uaJHQr0AEEaYyM82"]],[148,"Mường Thanh",0,2,25,25,25,1,false,5,[0,"2frm37uaJHQr0AEEaYyM82"]],[90,"ĐÀ NẴNG",0,18,18,1,false,false,6,[0,"6bLcpm4FZAhYBGBdmfGkj4"]],[41,0,8,[0,"e71ctEmpxFC4KlSYRZNz/a"]]],0,[0,7,1,0,0,1,0,41,12,0,42,11,0,43,10,0,15,9,0,44,3,0,45,2,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,-6,8,0,-7,7,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,0,3,0,0,4,0,-2,9,0,0,4,0,0,5,0,-2,10,0,0,5,0,0,6,0,-2,11,0,0,6,0,0,7,0,0,7,0,0,7,0,0,8,0,-2,12,0,14,1,36],[0,0,0,9,10,11],[1,1,1,2,2,2],[53,54,55,5,5,5]],[[[186,"builtin-particle",[{"hash":66662317,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplers":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":2019975772,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplers":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":1657678029,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplers":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]},{"hash":1671779194,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1}],"defines":[]}],"samplers":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_texCoord","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord1","type":15,"count":1,"stageFlags":1,"format":32,"location":2,"defines":[]},{"name":"a_texCoord2","type":15,"count":1,"stageFlags":1,"format":32,"location":3,"defines":[]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":4,"defines":[]},{"name":"a_color1","type":15,"count":1,"stageFlags":1,"format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[{"name":"loading_icon","rect":{"x":615,"y":1254,"width":179,"height":192},"offset":{"x":0,"y":0},"originalSize":{"width":201,"height":200},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"logo_daugianguoc","rect":{"x":810,"y":963,"width":653,"height":418},"offset":{"x":0,"y":0},"originalSize":{"width":653,"height":418},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"COIN_2","rect":{"x":759,"y":889,"width":45,"height":71},"offset":{"x":0,"y":1},"originalSize":{"width":75,"height":75},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[53,"ItemNotification"],[105,"ItemNotification",33554432,[-6],[[1,-2,[0,"f7NISe7HdAD68SLfhnddy8"],[5,500,51]],[10,1,0,-3,[0,"e71ctEmpxFC4KlSYRZNz/a"],0],[187,-5,[0,"88W+AM2qdM7YL43Rm/wu6E"],-4]],[8,"7aFiDHn+NClKHPLQ2dj3zj",-1,0]],[18,"Label",33554432,1,[[[1,-7,[0,"c68UOAlNhN171Umca6yVvF"],[5,440,36]],-8,[125,45,60,15,42.22,50.4,-9,[0,"cduD0aCNtBFK4RCCgUXAF2"]]],4,1,4],[8,"84yO6BiwFDMrUdCMsCSdJv",1,0],[1,30,-7.5,0]],[149,0,20,20,1,false,false,2,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4281479730]]],0,[0,7,1,0,0,1,0,0,1,0,46,3,0,0,1,0,-1,2,0,0,2,0,-2,3,0,0,2,0,14,1,9],[0,3],[1,2],[56,5]],[[{"name":"white","rect":{"x":1152,"y":1959,"width":64,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":64,"height":64},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"main_sapdaugia_bamboo","rect":{"x":821,"y":499,"width":280,"height":423},"offset":{"x":0,"y":0},"originalSize":{"width":280,"height":423},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[53,"ItemWinner"],[56,"ItemWinner",33554432,[-8,-9],[[1,-2,[0,"6a606hNzlLpqqTAXDGFzGt"],[5,670,94]],[188,-7,[0,"cdU5nomflBaaim4DBRE2pb"],-6,-5,-4,-3]],[8,"80oVypFg9Ea5rK9ZuAfYlh",-1,0],[1,0,617,0]],[70,"Container",33554432,1,[-12,-13,-14],[[1,-10,[0,"3242DVCWtMepBNxixN/wo6"],[5,620,94]],[77,1,1,-11,[0,"e8diY6Q/dBM44Z0QaBSR6K"]]],[8,"2cAB3vm0dMyI7ZFgt7HE8v",1,0]],[18,"Time",33554432,2,[[[3,-15,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],-16,[78,8,-17,[0,"76P+K5zndN1ppeFGoea51Q"]]],4,1,4],[8,"138ACOBEhDCJHTetcW3C00",1,0],[1,-310,0,0]],[73,"Bg",33554432,1,[[[1,-18,[0,"f7NISe7HdAD68SLfhnddy8"],[5,670,94]],-19],4,1],[8,"a8OMyFqFRGBqO1fu7Q0rmJ",1,0]],[18,"Winner",33554432,2,[[[3,-20,[0,"c68UOAlNhN171Umca6yVvF"],[5,340,94],[0,0,0.5]],-21],4,1],[8,"8aK+R4pM9M2YIhahqJqu60",1,0],[1,-170,0,0]],[18,"Price",33554432,2,[[[3,-22,[0,"c68UOAlNhN171Umca6yVvF"],[5,140,94],[0,0,0.5]],-23],4,1],[8,"4e/TVRUaZFHJwrL1PpdXPr",1,0],[1,170,0,0]],[41,0,4,[0,"e71ctEmpxFC4KlSYRZNz/a"]],[66,"02/07\n16:59",0,25,25,30,1,3,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380]],[66,"Khách sạn Mường Thanh",0,25,25,30,1,5,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380]],[66,"2",0,25,25,30,1,6,[0,"2frm37uaJHQr0AEEaYyM82"],[4,4284769380]]],0,[0,7,1,0,0,1,0,16,10,0,47,9,0,15,8,0,17,7,0,0,1,0,-1,4,0,-2,2,0,0,2,0,0,2,0,-1,3,0,-2,5,0,-3,6,0,0,3,0,-2,8,0,0,3,0,0,4,0,-2,7,0,0,5,0,-2,9,0,0,6,0,-2,10,0,14,1,23],[7],[1],[1]],[[{"name":"biginfor_board_pink","rect":{"x":983,"y":1622,"width":200,"height":190},"offset":{"x":0,"y":0},"originalSize":{"width":200,"height":190},"rotated":false,"capInsets":[60,60,60,60],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"textbox_bg","rect":{"x":647,"y":954,"width":100,"height":110},"offset":{"x":0,"y":0},"originalSize":{"width":100,"height":110},"rotated":false,"capInsets":[30,30,30,30],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"button_expand","rect":{"x":231,"y":1881,"width":108,"height":108},"offset":{"x":0,"y":0},"originalSize":{"width":108,"height":108},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[54,"Gobold Uplow","Gobold Uplow.ttf"]],0,0,[],[],[]],[[{"name":"mainscreen_timing_a","rect":{"x":1107,"y":109,"width":548,"height":119},"offset":{"x":0,"y":22},"originalSize":{"width":560,"height":175},"rotated":true,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[{"name":"title","rect":{"x":3,"y":954,"width":638,"height":168},"offset":{"x":0,"y":0},"originalSize":{"width":638,"height":168},"rotated":false,"capInsets":[0,0,0,0],"texture":"13630127d@6c48a","packable":true}],[0],0,[0],[3],[0]],[[[189,[[190,"ShadowFlow",[[191,"ShadowStage"]]],[192,"ForwardFlow",1,[[193,"ForwardStage",[[194,["default"]],[195,true,1,["default"]]]]]]]]],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0}],[6],0,[],[],[]],[[{"base":"2,2,0,0,0,1","mipmaps":["ffuIqPr2JI9I8dPLYGRDpD"]}],[7],0,[],[],[]],[[{"name":"default_scrollbar_vertical_bg","rect":{"x":0,"y":0,"width":15,"height":30},"offset":{"x":0,"y":0},"originalSize":{"width":15,"height":30},"rotated":false,"capInsets":[4,10,4,10],"texture":"ffb88a8f-af62-48f4-8f1d-3cb606443a43@6c48a","packable":true}],[0],0,[0],[3],[57]]]]
